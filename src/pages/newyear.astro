---
// src/pages/newyear.astro
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026æ–°å¹´ç¥ç¦</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* ============================================================ */
        /* ====== [æ–°å¢] å¼€åœºåŠ¨ç”»å±‚ (Intro Layer) ====== */
        /* ============================================================ */
        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000;
            z-index: 100; /* æœ€é«˜å±‚çº§ */
            display: flex; justify-content: center; align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px; letter-spacing: 4px; font-weight: 300;
            pointer-events: none; /* åŠ¨ç”»æœŸé—´ä¸è®©ç‚¹ */
            opacity: 1;
            transition: opacity 1s; /* é»˜è®¤æ·¡å‡ºé€Ÿåº¦ï¼ŒJSä¸­ä¼šåŠ¨æ€æ§åˆ¶ */
        }
        
        /* å‘¼å¸ç¯åŠ¨ç”»æ•ˆæœ */
        .breathing {
            animation: breathe 3s ease-in-out infinite;
        }
        @keyframes breathe {
            0% { opacity: 0.3; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); text-shadow: 0 0 15px rgba(255,255,255,0.5); }
            100% { opacity: 0.3; transform: scale(0.95); }
        }

        /* ============================================================ */
        
        #ui-layer {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; z-index: 10;
            transition: opacity 0.5s;
            width: 100%;
            pointer-events: auto;
            /* [ä¿®æ”¹] åˆå§‹é€æ˜åº¦è®¾ä¸º0ï¼Œç­‰å¾…å¼€åœºåŠ¨ç”»ç»“æŸåæ˜¾ç¤º */
            opacity: 0; 
            display: none; /* åˆå§‹éšè— */
        }
        
        /* [ä¿®æ”¹] è¾“å…¥æ¡†æ ·å¼ï¼šç”±åŸæœ¬çš„çº¢è‰²æ”¹ä¸ºæµ…ç°è‰²ä½è°ƒé£æ ¼ */
        input {
            padding: 15px 20px; font-size: 18px; border-radius: 30px;
            /* åŸæ¥çš„çº¢è‰²è¾¹æ¡†è¢«æ³¨é‡Šæ‰ï¼Œæ”¹ä¸ºæµ…ç° */
            /* border: 2px solid #ff4d4d; */
            border: 2px solid rgba(255, 255, 255, 0.3); 
            background: rgba(0,0,0,0.8);
            color: white; outline: none; text-align: center; width: 60%; max-width: 300px;
            margin-bottom: 20px;
            /* åŸæ¥çš„çº¢è‰²é˜´å½±æ”¹ä¸ºæµ…ç™½é˜´å½± */
            /* box-shadow: 0 0 15px rgba(255, 77, 77, 0.3); */
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        button {
            padding: 12px 50px; font-size: 18px;
            border-radius: 30px; border: none; background: linear-gradient(45deg, #ff4d4d, #ff8c00);
            color: white; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.5);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        /* [æ–°å¢] å…è´£å£°æ˜æ ·å¼ */
        #disclaimer {
            margin-top: 25px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
        }
        
        #hint {
            position: absolute; bottom: 10%; width: 100%;
            text-align: center; color: rgba(255,255,255,0.6); font-size: 14px;
            pointer-events: none; opacity: 0; transition: opacity 1s;
            letter-spacing: 2px;
        }

        /* [æ–°å¢] åº•éƒ¨äº¤äº’æç¤ºè¯­ (æˆ³æˆ³å±å¹•æœ‰æƒŠå–œ) */
        #touch-hint {
            position: absolute;
            bottom: 12%; /* ä½äºæŒ‰é’®ä¸Šæ–¹ä¸€ç‚¹ç‚¹ */
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            pointer-events: none;
            opacity: 0; /* åˆå§‹éšè— */
            transition: opacity 1s;
            letter-spacing: 1px;
            z-index: 19;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }

        /* [ä¿®æ”¹] æ§åˆ¶æ å®¹å™¨ - ä¸å†è´Ÿè´£å…·ä½“å¸ƒå±€ï¼Œåªä½œä¸ºä¸€ä¸ªå…¨å±è¦†ç›–å±‚ */
        #controls-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%; /* å…¨å±è¦†ç›– */
            z-index: 20;
            opacity: 1; 
            transition: opacity 1.5s;
            pointer-events: none; /* è‡ªèº«ä¸æŒ¡ç‚¹å‡»ï¼Œå­å…ƒç´ æŒ‰é’®æŒ¡ç‚¹å‡» */
        }

        .control-btn {
            pointer-events: auto;
            display: inline-block;
            padding: 8px 16px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1); /* åŠé€æ˜èƒŒæ™¯ */
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(4px); /* ç£¨ç ‚ç»ç’ƒæ•ˆæœ */
            transition: all 0.3s;
            text-decoration: none;
            box-shadow: none; /* ç§»é™¤åŸæ¥çš„å‘å…‰é˜´å½±ï¼Œä¿æŒä½è°ƒ */
            background-image: none; /* ç§»é™¤åŸæ¥çš„æ¸å˜ */
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap; /* é˜²æ­¢æ–‡å­—æ¢è¡Œå½±å“å¸ƒå±€ */
        }
        
        /* [æ–°å¢] åˆå§‹éšè—çš„æŒ‰é’® (è‡ªåŠ¨çƒŸèŠ± å’Œ è¿”å›åšå®¢)ï¼Œç­‰åˆ° Final é˜¶æ®µæ‰æ˜¾ç¤º */
        .initially-hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.9);
            transition: all 0.5s ease-out; /* æ·»åŠ å¹³æ»‘è¿‡æ¸¡ */
        }
        
        /* [ä¿®æ”¹] å·¦å³æŒ‰é’®çš„å®šä½æ ·å¼ - è¿™é‡Œä»…è®¾ç½® positionï¼Œå…·ä½“ top/bottom/left/right ç”± JS åŠ¨æ€æ§åˆ¶ */
        #btn-auto {
            position: absolute;
            /* æ ·å¼ç”± JS çš„ CONFIG.ui.positions æ§åˆ¶ */
        }

        #btn-blog {
            position: absolute;
            /* æ ·å¼ç”± JS çš„ CONFIG.ui.positions æ§åˆ¶ */
        }

        /* æ˜¾ç¤ºçŠ¶æ€ç±» */
        .reveal-btn {
            opacity: 1 !important;
            pointer-events: auto !important;
            transform: scale(1) !important;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }

        .control-btn.active {
            background: rgba(255, 77, 77, 0.4); /* æ¿€æ´»çŠ¶æ€ç¨å¾®çº¢ä¸€ç‚¹ */
            border-color: #ff4d4d;
            color: #fff;
        }

        /* ============================================================ */
        /* ====== [ä¿®æ”¹] éŸ³é‡æ§åˆ¶æ ·å¼ (æ•´åˆåˆ°åº•éƒ¨ä¸­é—´) ====== */
        /* ============================================================ */
        
        /* éŸ³é‡æŒ‰é’®å®¹å™¨ (ç”¨äºå®šä½å¼¹å‡ºé¢æ¿) */
        /* [ä¿®æ”¹] è¿™é‡Œè®¾ç½®ä¸ºç»å¯¹å®šä½ï¼Œå…·ä½“ä½ç½®ç”± JS æ§åˆ¶ */
        .volume-container {
            position: absolute;
            /* æ ·å¼ç”± JS çš„ CONFIG.ui.positions æ§åˆ¶ */
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1; 
            z-index: 25;
        }

        /* è§¦å‘æŒ‰é’®æ ·å¼ (ä¿æŒå’Œå…¶ä»–æŒ‰é’®ä¸€è‡´) */
        #volume-trigger-btn {
            width: 40px; 
            height: 36px; /* å’Œå…¶ä»–æŒ‰é’®å·®ä¸å¤šé«˜ */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            padding: 0; /* å›¾æ ‡å±…ä¸­ */
        }

        /* [ä¿®æ”¹] å‘ä¸Šå¼¹å‡ºçš„é¢æ¿ - æç®€é£æ ¼ */
        #volume-panel-vertical {
            position: absolute;
            bottom: 50px; /* è·ç¦»åº•éƒ¨æŒ‰é’®çš„è·ç¦» */
            left: 50%;
            /* åˆå§‹çŠ¶æ€ï¼šä¸‹ç§»ä¸”ç¼©å° */
            transform: translateX(-50%) translateY(20px) scale(0.9); 
            
            /* [ä¿®æ”¹] å®½åº¦åŠ å®½ï¼Œä»¥å®¹çº³å·¦å³ä¸¤ä¸ªæ»‘å— */
            width: 140px; 
            height: 140px; /* é«˜åº¦é€‚ä¸­ */
            
            /* [UI ä¿®æ”¹] å»æ‰å¤§è‰²å—èƒŒæ™¯ï¼Œæ”¹ä¸ºæç®€ */
            background: transparent; 
            /* å¦‚æœéœ€è¦ä¸€ç‚¹ç‚¹èƒŒæ™¯ä¿è¯æ–‡å­—å¯è§ï¼Œå¯ä»¥ç”¨ææ·¡çš„æ¸å˜ï¼Œè¿™é‡Œå…ˆè®¾ä¸ºå…¨é€æ˜çªå‡ºæç®€ */
            
            display: flex;
            flex-direction: row; 
            align-items: flex-end; /* åº•éƒ¨å¯¹é½ */
            justify-content: center; 
            gap: 20px; /* ä¸¤ä¸ªéŸ³é‡æ¡ä¹‹é—´çš„é—´è· */
            padding-bottom: 10px;
            
            opacity: 0;
            pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1); /* å¼¹æ€§å¼¹å‡ºåŠ¨ç”» */
            z-index: 100;
        }

        #volume-panel-vertical.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            pointer-events: auto;
        }

        /* æ»‘å—åŒ…è£…å™¨ */
        .vol-slider-wrap {
            height: 100%; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            width: 30px;
        }

        .vol-icon-small {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            margin-top: 10px; /* å›¾æ ‡åœ¨æ»‘å—ä¸‹æ–¹ */
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        /* [UI ä¿®æ”¹] æç®€ç»†çº¿æ¡é£æ ¼æ»‘å— */
        
        /* å®¹å™¨éœ€è¦æ—‹è½¬ï¼Œå› ä¸º range é»˜è®¤æ˜¯æ¨ªå‘çš„ */
        .range-holder {
            width: 30px;
            height: 100px; /* è½¨é“è§†è§‰é•¿åº¦ */
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        input[type=range].vertical-range-transform {
            -webkit-appearance: none; /* æ¸…é™¤é»˜è®¤æ ·å¼ */
            width: 100px; /* å®é™…å®½åº¦ (æ—‹è½¬åå˜æˆé«˜åº¦) */
            height: 20px; /* è§¦æ§åŒºåŸŸé«˜åº¦ï¼Œä¸å½±å“è§†è§‰çº¿æ¡ç²—ç»† */
            background: transparent;
            transform: rotate(-90deg); /* æ—‹è½¬90åº¦å˜æˆç«–å‘ */
            outline: none;
            cursor: pointer;
        }

        /* è½¨é“æ ·å¼ (Chrome/Safari/Edge) */
        input[type=range].vertical-range-transform::-webkit-slider-runnable-track {
            width: 100%;
            height: 2px; /* çº¿æ¡ç²—ç»†ï¼šç»†çº¿ */
            background: rgba(255, 255, 255, 0.3); /* åŠé€æ˜ç™½çº¿ */
            border-radius: 1px;
            border: none;
        }

        /* æ»‘å—åœ†ç‚¹æ ·å¼ (Chrome/Safari/Edge) */
        input[type=range].vertical-range-transform::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #ffffff; /* çº¯ç™½åœ†ç‚¹ */
            margin-top: -6px; /* (è½¨é“é«˜åº¦2px / 2) - (åœ†ç‚¹é«˜åº¦14px / 2) = 1 - 7 = -6 */
            box-shadow: 0 0 5px rgba(0,0,0,0.3); /* è½»å¾®é˜´å½± */
            border: none;
        }

        /* Firefox å…¼å®¹ */
        input[type=range].vertical-range-transform::-moz-range-track {
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 1px;
            border: none;
        }
        input[type=range].vertical-range-transform::-moz-range-thumb {
            height: 14px;
            width: 14px;
            border-radius: 50%;
            background: #ffffff;
            border: none;
            box-shadow: 0 0 5px rgba(0,0,0,0.3);
        }

    </style>
</head>
<body>

    <div id="intro-layer">
        <div id="intro-text" class="breathing"></div>
    </div>

    <div id="ui-layer">
        <input type="text" id="nameInput" placeholder="è¯·è¾“å…¥ä½ çš„åå­—" maxlength="12">
        <br>
        <button onclick="startShow()">å¼€å¯ 2026</button>
        <div id="disclaimer"></div>
    </div>

    <div id="hint">ç‚¹å‡»å±å¹•ç»§ç»­...</div>

    <div id="touch-hint">æˆ³æˆ³å±å¹•æœ‰æƒŠå–œ</div>

    <div id="controls-layer">
        <button class="control-btn initially-hidden" id="btn-auto" onclick="toggleAutoFire()">è‡ªåŠ¨æ”¾çƒŸèŠ±: å…³</button>
        
        <div class="volume-container">
            <div id="volume-panel-vertical">
                <div class="vol-slider-wrap">
                    <div class="range-holder">
                        <input type="range" class="vertical-range-transform" min="0" max="1" step="0.01" value="0.5" id="sfx-slider" oninput="updateSfxVolume(this.value)">
                    </div>
                    <span class="vol-icon-small">ğŸ’¥</span>
                </div>
                <div class="vol-slider-wrap">
                    <div class="range-holder">
                        <input type="range" class="vertical-range-transform" min="0" max="1" step="0.01" value="0.5" id="bgm-slider" oninput="updateBgmVolume(this.value)">
                    </div>
                    <span class="vol-icon-small">ğŸµ</span>
                </div>
            </div>
            <button class="control-btn" id="volume-trigger-btn" onclick="toggleVolumePanel()">ğŸ”Š</button>
        </div>

        <button class="control-btn initially-hidden" id="btn-blog" onclick="goBlog()">è®¿é—®æˆ‘çš„åšå®¢</button>
    </div>

    <canvas id="canvas"></canvas>

    <script is:inline>
        // ================= è‡ªå®šä¹‰è°ƒæ•´åŒº =================
        const CONFIG = {
            // ============================================
            // ====== [æ–°å¢] å¼€åœºåŠ¨ç”»é…ç½® (INTRO) ======
            // ============================================
            intro: {
                // æ˜¯å¦å¯ç”¨å¼€åœºåŠ¨ç”»
                enabled: true, 

                // [é…ç½®ç‚¹ 4] true = æ— è®ºå¤šå°‘æ¬¡è®¿é—®éƒ½æ˜¾ç¤º; false = ç¬¬ä¸€æ¬¡è®¿é—®æ˜¾ç¤ºï¼Œä¹‹ååˆ·æ–°ä¸æ˜¾ç¤º
                alwaysShow:true, 

                // å¼€åœºæ˜¾ç¤ºçš„æ–‡å­—åºåˆ— (å¯è‡ªå®šä¹‰)
                texts: ["å»ºè®®å¼€å¯å£°éŸ³<br>è·å¾—æœ€ä½³ä½“éªŒ", "Maxton ä½œå“"],
                
                // æ¯ä¸ªæ–‡å­—æ˜¾ç¤ºçš„åœç•™æ—¶é—´ (æ¯«ç§’)
                duration: 2000, 
                
                // æ·¡å…¥æ·¡å‡ºçš„è¿‡æ¸¡æ—¶é—´ (æ¯«ç§’)
                fadeSpeed: 1000
            },

            // ============================================
            // ====== [1. æ–‡å­—å†…å®¹é…ç½® (TEXT CONTENT)] ======
            // ============================================
            
            // [åŸæœ‰] å¦‚æœä¸‹é¢çš„ textLogic.randomize ä¸º falseï¼Œåˆ™ä½¿ç”¨è¿™äº›å›ºå®šçš„è¯
            transitionTexts: ["å‰ç¨‹ä¼¼é”¦", "å­¦ä¸šæœ‰æˆ","å¹³å®‰å–œä¹"],
            carouselTexts: ["è´¢æºå¹¿è¿›", "å‰æ˜Ÿé«˜ç…§", "å¿ƒæƒ³äº‹æˆ", "ä¸€å¸†é£é¡º", "æœªæ¥å¯æœŸ"],

            // [æ–°å¢åŠŸèƒ½] è¯æ±‡åº“é€»è¾‘æ§åˆ¶
            textLogic: {
                // æ˜¯å¦å¼€å¯éšæœºæŠ½å–ï¼Ÿ 
                // true = æ¯æ¬¡åˆ·æ–°ç½‘é¡µéƒ½ä» pool é‡Œéšæœºé€‰è¯è¦†ç›–ä¸Šé¢çš„æ•°ç»„
                // false = ä½¿ç”¨ä¸Šé¢å›ºå®šçš„ transitionTexts å’Œ carouselTexts
                randomize: true, 

                // éšæœºæŠ½å–æ•°é‡é…ç½®
                transitionCount: 3, // ä¸Šé¢éšæœºé€‰3ä¸ª
                carouselCount: 5,   // ä¸‹é¢éšæœºé€‰5ä¸ª

                // å¤§è¯åº“ (Pool) - ä½ å¯ä»¥æ— é™å¾€è¿™é‡ŒåŠ è¯
                pool: [
                    "å‰ç¨‹ä¼¼é”¦", "å­¦ä¸šæœ‰æˆ", "å¹³å®‰å–œä¹", "è´¢æºå¹¿è¿›", "å‰æ˜Ÿé«˜ç…§", 
                    "å¿ƒæƒ³äº‹æˆ", "ä¸€å¸†é£é¡º", "æœªæ¥å¯æœŸ", "ä¸‡äº‹å¦‚æ„", "èº«ä½“å¥åº·",
                    "æ­¥æ­¥é«˜å‡", "é˜–å®¶å¹¸ç¦", "å¤§å±•å®å›¾", "é‡‘æ¦œé¢˜å", "å¥½è¿è¿è¿",
                    "ç¬‘å£å¸¸å¼€", "æ—¥è¿›æ–—é‡‘", "é£é»„è…¾è¾¾", "è¯¸äº‹é¡ºé‚", "ç¦æ˜Ÿé«˜ç…§",
                    "å²å²å¹³å®‰", "å¹´å¹´æœ‰ä½™", "äº‹ä¸šæœ‰æˆ", "æ¢¦æƒ³æˆçœŸ"
                ]
            },

            textColors: {
                initialMode: 'gold', // 'gold', 'red', 'rainbow', 'white'
                randomize: false      // æ˜¯å¦éšæœºå˜è‰²
            },

            // ============================================
            // ====== [2. å­—ä½“ä¸æ’ç‰ˆ (FONTS & LAYOUT)] ======
            // ============================================
            fontSizes: {
                // [å¼€åœºæ–‡å­—] (è¾“å…¥åå­—åçš„é‚£ä¸ªå¤§å­—)
                introMobile: 85,    // æ‰‹æœºç«¯å¤§å° (å¤ªå¤§å¯èƒ½ä¼šè¶…å‡ºå±å¹•)
                introDesktop:200,   // ç”µè„‘ç«¯å¤§å°

                // [æœ€ç»ˆé¡µé¢] ä¸ŠåŠéƒ¨åˆ†çš„é™æ€å­—
                finalTitleMobile: 55,   // "ç¥"
                finalTitleDesktop: 80,
                
                finalNameMobile: 90,    // ä½ çš„åå­—
                finalNameDesktop: 130,
                
                finalYearMobile: 70,    // "2026"
                finalYearDesktop: 100,
                
                // [æœ€ç»ˆé¡µé¢] åº•éƒ¨æ—‹è½¬åœ†ç¯çš„å­—
                carouselMobile: 55, 
                carouselDesktop: 100
            },

            // --- 3D å¸ƒå±€å‚æ•° ---
            // [ä¸­å¿ƒé«˜åº¦] 0=é¡¶éƒ¨, 0.5=å±å¹•æ­£ä¸­é—´, 1=åº•éƒ¨
            centerYMobile: 0.53,    
            centerYDesktop: 0.5,    
            
            // [åœ†ç¯åŠå¾„] å±å¹•å®½åº¦çš„å€æ•°ã€‚å¤ªå¤§å­—ä¼šå‡ºå±å¹•ï¼Œå¤ªå°å­—æŒ¤åœ¨ä¸€èµ·ã€‚
            carouselRadiusRatioMobile: 0.45, 
            carouselRadiusRatioDesktop: 0.2, 

            // [ä¿¯è§†è§’åº¦] 0=å¹³è§†(ä¸€æ¡çº¿), 1=å®Œå…¨ä¿¯è§†(æ­£åœ†)
            tiltFactorMobile: 0.5,    
            tiltFactorDesktop: 0.4,   
            
            // [é€è§†æ„Ÿ] æ•°å€¼è¶Šå°ï¼Œè¿‘å¤§è¿œå°çš„æ•ˆæœè¶Šå¤¸å¼ ã€‚
            fovMobile: 1000,    
            fovDesktop: 1400,

            // ============================================
            // ====== [3. ç²’å­ç³»ç»Ÿè®¾ç½® (PARTICLES)] ======
            // ============================================
            // æ•°å€¼ä»£è¡¨â€œæ¯éš”å¤šå°‘ä¸ªåƒç´ å–ä¸€ä¸ªç‚¹â€ã€‚
            // 1 = æœ€å¯† (100% è¿˜åŸ), 1.5 = é€‚ä¸­, 2 = ç¨€ç–
            density: {
                // å¼€åœºé˜¶æ®µ
                introMobile: 1.4,    // â˜… å»ºè®®è®¾ç½® 1.3 ~ 1.6 ä¹‹é—´
                introDesktop: 2,
                
                // æœ€ç»ˆé˜¶æ®µ (å› ä¸ºå­—å¤šï¼Œå»ºè®®æ¯”ä¸Šé¢ç¨å¾®å¤§ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢å¤ªä¹±)
                finalMobile: 1.6,    // â˜… å»ºè®®è®¾ç½® 2.0 ~ 2.5
                finalDesktop: 3
            },

            // --- è§†è§‰ä¸å‘å…‰æ§åˆ¶ ---
            visuals: {
                // [å…¨å±€å‘å…‰] true: å¼€å¯æš´åŠ›å åŠ æ¨¡å¼ï¼Œæ‰€æœ‰ç²’å­éƒ½å‘å…‰ã€‚
                globalAdditive: false, 

                // [å‘¼å¸é«˜äº®] true: åªæœ‰â€œæ­£åœ¨é—ªçƒâ€çš„ç²’å­æ‰å¼€å¯é«˜äº®å åŠ ã€‚
                twinkleAdditive: true,

                // [åŸºç¡€äº®åº¦] èŒƒå›´ 0.1(æš—) ~ 1.0(äº®)ã€‚
                alphaFactor: 0.8
            },

            // --- ç²’å­å‘¼å¸/é—ªçƒå‚æ•° ---
            twinkle: {
                enabled: true,       // æ€»å¼€å…³
                probability: 0.9,    // é—ªçƒå¯†åº¦ (0.7 = 70% çš„ç²’å­ä¼šå‚ä¸é—ªçƒ)
                minOpacity: 0.1,     // [æ˜æš—å¯¹æ¯”åº¦] é—ªçƒæ—¶æœ€æš—èƒ½åˆ°å¤šå°‘
                maxOpacity: 1.0,     // é—ªçƒæ—¶æœ€äº®èƒ½åˆ°å¤šå°‘
                speedMin: 0.03,      // é—ªçƒé€Ÿåº¦ä¸‹é™
                speedMax: 0.06,      // é—ªçƒé€Ÿåº¦ä¸Šé™
                
                // [é”åŒ–ç³»æ•°] 1 = å¹³æ»‘, 3 = å°–é” (åƒæ˜Ÿæ˜Ÿ)
                sharpness: 2.5  
            },

            // ============================================
            // ====== [4. åŠ¨ç”»ä¸ç‰©ç† (ANIMATION)] ======
            // ============================================
            rotationSpeed: 0.0012, // åº•éƒ¨åœ†ç¯æ—‹è½¬é€Ÿåº¦
            particleEase: 0.05,    // ç²’å­é£è¡Œçš„åˆ¹è½¦åŠ›åº¦ (0.01=è¶…æ…¢, 0.1=è¶…å¿«)

            // ============================================
            // ====== [5. èƒŒæ™¯ä¸æ°›å›´ (BACKGROUND)] ======
            // ============================================
            background: {
                enabled: true,       // æ˜¯å¦å¼€å¯èƒŒæ™¯æ¼‚æµ®ç‰©
                
                // æ ·å¼é€‰æ‹©: 'mix'(æ··åˆæ¨è), 'circle'(åœ†), 'cross'(åå­—), 'ring'(ç©ºå¿ƒåœˆ)
                style: 'mix',

                // èƒŒæ™¯ç²’å­æ•°é‡
                countMobile: 40,     
                countDesktop: 80,

                // æ¼‚æµ®é€Ÿåº¦ (è¶Šå°è¶Šæ…¢ï¼Œè¥é€ å¤ªç©ºæ„Ÿ)
                speed: 0.3,           

                // ç²’å­å¤§å°èŒƒå›´
                sizeMin: 2.0,
                sizeMax: 8.0,

                // é¢œè‰²ä¸é€æ˜åº¦
                color: '255, 255, 255', // RGB é¢œè‰²
                opacity: 0.4            // åŸºç¡€é€æ˜åº¦
            },

            // ============================================
            // ====== [6. çƒŸèŠ±ç³»ç»Ÿé…ç½® (FIREWORKS)] ======
            // ============================================
            fireworks: {
                // ä¸Šå‡é€Ÿåº¦ (æ•°å€¼è¶Šå¤§è¶Šå¿«)
                launchSpeedMobile: 3,
                launchSpeedDesktop: 4,

                // ä¸Šå‡æ—¶çš„æŠ–åŠ¨å¹…åº¦ (æ¨¡æ‹Ÿé£è¡Œä¸ç¨³)
                ascentWobble: 3, 

                // çˆ†ç‚¸åç²’å­æ•°é‡
                explosionCountMobile: 60,
                explosionCountDesktop: 120,

                // çˆ†ç‚¸åŠ›åº¦ (Spread)
                explosionForce: 6,
                
                // é‡åŠ› (çƒŸèŠ±ä¸‹å çš„æ„Ÿè§‰)
                gravity: 0.05,
                
                // é˜»åŠ› (ç©ºæ°”é˜»åŠ›ï¼Œé˜²æ­¢é£å¤ªè¿œ)
                friction: 0.96,

                // ç²’å­æ®‹ç•™æ—¶é—´æ§åˆ¶ (æ•°å€¼è¶Šå°ï¼Œæ¶ˆå¤±è¶Šæ…¢)
                decayMin: 0.003,
                decayMax: 0.008,

                // --- çˆ†ç‚¸èŠ±æ · ---
                patterns: {
                    // çˆ†ç‚¸å½¢çŠ¶æ§åˆ¶ï¼šæ˜¯å¦å¯ç”¨å¤šç§èŠ±æ ·
                    enabled: true, 

                    // çˆ†ç‚¸èŒƒå›´ç¼©æ”¾ (Scale)
                    scaleMobile: 1.2,
                    scaleDesktop: 1.5 
                },

                // --- æ–‡å­—çƒŸèŠ± (æ ¸å¿ƒåŠŸèƒ½) ---
                textFireworks: {
                    enabled: true,
                    
                    // å‡ºç°çš„æ¦‚ç‡ (0.3 è¡¨ç¤º 30% çš„çƒŸèŠ±ä¼šç‚¸æˆæ–‡å­—)
                    probability: 0.3, 

                    // ç¥ç¦è¯­åˆ—è¡¨ (ç‚¸å¼€æ—¶éšæœºé€‰ä¸€ä¸ª)
                    words: ["ç¦", "ä¹", "é¡º", "å‘", "å‰", "å®‰"],
                    
                    // æ–‡å­—ç²’å­çš„å¤§å°
                    particleSizeMobile: 1.8,
                    particleSizeDesktop: 2.5,

                    // æ–‡å­—ç‚¸å¼€çš„èŒƒå›´å¤§å°
                    explosionScaleMobile: 1.5,
                    explosionScaleDesktop: 2.2,

                    // æ–‡å­—çƒŸèŠ±çš„æŒç»­æ—¶é—´
                    decaySpeed: 0.004,

                    // é¢œè‰²æ§åˆ¶æ¨¡å¼: 'gold', 'random', 'fixed'
                    colorMode: 'random', 
                    
                    // å½“ colorMode ä¸º 'fixed' æ—¶ç”Ÿæ•ˆ
                    fixedColor: '255, 255, 255'
                },

                // --- å°¾çƒŸé…ç½® ---
                smoke: {
                    enabled: true,
                    color: '180, 180, 180',
                    sizeMobile: 1.5,
                    sizeDesktop: 2.5,
                    decaySpeed: 0.02,
                    interval: 2,
                    jitter: 0.5
                }
            },

            // ============================================
            // ====== [7. UI ä¸äº¤äº’ (UI)] ======
            // ============================================
            ui: {
                // åšå®¢è·³è½¬é“¾æ¥
                blogUrl: "https://zh.maxtonniu.com",

                // åº•éƒ¨é˜²è¯¯è§¦åŒºåŸŸé«˜åº¦ (px)
                safeZoneHeightMobile: 100,
                safeZoneHeightDesktop: 80,

                // æç¤ºè¯­æ–‡å­—
                touchHintText: "æˆ³æˆ³å±å¹•æœ‰æƒŠå–œ",

                // [æ–°å¢] å…è´£å£°æ˜å†…å®¹é…ç½®
                disclaimer: {
                    text: "æœ¬ç½‘é¡µåŸºäºçº¯é™æ€å‰ç«¯ï¼Œä¸ä¼šæ”¶é›†æ‚¨ä»»ä½•è¾“å…¥çš„ä¸œè¥¿ï¼ˆæˆ‘å“ªæœ‰è¿™é—²é’±ä¹°æœåŠ¡å™¨è¿™ä¸œè¥¿ï¼‰",
                    color: "rgba(255, 255, 255, 0.4)",
                    fontSize: "12px"
                },

                // è‡ªåŠ¨æ”¾çƒŸèŠ±çš„å‚æ•°
                autoFire: {
                    minInterval: 300,  // æœ€å¿«å¤šä¹…æ”¾ä¸€æ¬¡ (æ¯«ç§’)
                    maxInterval: 1200, // æœ€æ…¢å¤šä¹…æ”¾ä¸€æ¬¡ (æ¯«ç§’)
                    maxConcurrent: 3   // æ¯æ¬¡å¹¶å‘æœ€å¤šæ”¾å‡ ä¸ª?
                },

                // ==========================================================
                // ====== [æ ¸å¿ƒæ–°å¢] æŒ‰é’®ä½ç½®è‡ªå®šä¹‰é…ç½® (BUTTON POSITIONS) ======
                // ==========================================================
                // è¯´æ˜ï¼š
                // 1. åˆ†ä¸º 'mobile' (æ‰‹æœº) å’Œ 'desktop' (ç”µè„‘) ä¸¤å¥—é…ç½®ã€‚
                // 2. æ”¯æŒ top, bottom, left, right å››ä¸ªå±æ€§ã€‚
                // 3. å¦‚æœä¸éœ€è¦æŸä¸ªæ–¹å‘ï¼Œè¯·è®¾ä¸º null æˆ–æ³¨é‡Šæ‰ã€‚
                // 4. å•ä½å¯ä»¥æ˜¯ '%' (ç™¾åˆ†æ¯”) æˆ– 'px' (åƒç´ )ã€‚
                // ==========================================================
                positions: {
                    // --- 1. è‡ªåŠ¨æ”¾çƒŸèŠ±æŒ‰é’® (Auto Fire Button) ---
                    autoBtn: {
                        mobile: {
                            bottom: '4%',      // è·ç¦»åº•éƒ¨
                            left: '8%',        // è·ç¦»å·¦ä¾§
                            top: null, right: null // ä¸ç”¨ç®¡
                        },
                        desktop: {
                            bottom: '4%',
                            left: '8%',
                            top: null, right: null
                        }
                    },

                    // --- 2. è¿”å›åšå®¢æŒ‰é’® (Back Blog Button) ---
                    blogBtn: {
                        mobile: {
                            bottom: '4%',
                            right: '10%',       // è·ç¦»å³ä¾§
                            top: null, left: null
                        },
                        desktop: {
                            bottom: '4%',
                            right: '10%',
                            top: null, left: null
                        }
                    },

                    // --- 3. éŸ³é‡æ§åˆ¶æŒ‰é’® (Volume Button) ---
                    // æ³¨æ„ï¼šéŸ³é‡æ»‘å—é¢æ¿ä¼šè‡ªåŠ¨è·Ÿéšè¿™ä¸ªæŒ‰é’®
                    volumeBtn: {
                        mobile: {
                            bottom: '4%',
                            left: '50%',       // å±…ä¸­
                            // å¦‚æœä½¿ç”¨äº†ç™¾åˆ†æ¯”å±…ä¸­ï¼Œé€šå¸¸éœ€è¦é…åˆ CSS transform translateï¼Œ
                            // ä½†è¿™é‡Œæˆ‘ä»¬é€šè¿‡ JS ç®€å•å¤„ç†ï¼šå¦‚æœæ˜¯ 50%ï¼Œæˆ‘ä»¬æ‰‹åŠ¨ä¿®æ­£ä¸€ä¸‹ transformï¼Œ
                            // æˆ–è€…ä½ å¯ä»¥ç®€å•åœ°ä¸ç”¨ 50%ï¼Œè€Œæ˜¯ç”¨ padding ä¼°ç®—ã€‚
                            // ä¸ºäº†æ–¹ä¾¿ï¼Œæˆ‘ä»¬åœ¨ä¸‹é¢çš„ JS ä»£ç é‡ŒåŠ äº† transform: translateX(-50%) çš„å¤„ç†é€»è¾‘ã€‚
                            top: null, right: null
                        },
                        desktop: {
                            bottom: '4%',
                            left: '50%',
                            top: null, right: null
                        }
                    }
                }
            },

            // ============================================
            // ====== [8. éŸ³é¢‘ä¸éŸ³ä¹ (AUDIO)] ======
            // ============================================
            sound: {
                enabled: false,       // çƒŸèŠ±éŸ³æ•ˆæ€»å¼€å…³ (å»ºè®®ç”±æ»‘å—æ§åˆ¶)
                volume: 0.5,         // çƒŸèŠ±éŸ³æ•ˆå…¨å±€åˆå§‹éŸ³é‡ (0 ~ 1)
                
                // èµ„æºè·¯å¾„å®šä¹‰
                files: {
                    lift: ['/audio/lift1.mp3', '/audio/lift2.mp3', '/audio/lift3.mp3'],
                    burst: ['/audio/burst1.mp3', '/audio/burst2.mp3'],
                    burstSmall: ['/audio/burst-sm-1.mp3', '/audio/burst-sm-2.mp3'],
                    crackle: ['/audio/crackle1.mp3', '/audio/crackle-sm-1.mp3']
                }
            },

            // [æ–°å¢] èƒŒæ™¯éŸ³ä¹é…ç½® (BGM)
            music: {
                enabled: true,       // èƒŒæ™¯éŸ³ä¹æ€»å¼€å…³
                volume: 0.5,         // èƒŒæ™¯éŸ³ä¹åˆå§‹éŸ³é‡ (0 ~ 1)
                
                // éŸ³ä¹æ–‡ä»¶åˆ—è¡¨ (è¯·æ”¾åœ¨ public/audio/bgm/ ç›®å½•ä¸‹)
                // åˆ·æ–°é¡µé¢æ—¶ä¼šéšæœºä»è¿™é‡Œé€‰ä¸€é¦–ä½œä¸ºæœ¬æ¬¡çš„ BGM
                files: [
                    '/audio/bgm/daoxiang.mp3',
                    '/audio/bgm/xiyuanqian.mp3',
                    '/audio/bgm/longjuanfeng.mp3'
                ]
            }
        };
        // ===============================================

        // [æ–°å¢] åˆå§‹åŒ–è¯æ±‡é€»è¾‘ï¼šå¦‚æœå¼€å¯éšæœºï¼Œåˆ™è¦†ç›–åŸæœ‰çš„ transitionTexts å’Œ carouselTexts
        function initTextLogic() {
            if (CONFIG.textLogic.randomize && CONFIG.textLogic.pool.length > 0) {
                // 1. å…‹éš†å¹¶æ‰“ä¹±å¤§è¯åº“
                const shuffled = [...CONFIG.textLogic.pool].sort(() => Math.random() - 0.5);
                
                // 2. æˆªå–éœ€è¦çš„æ•°é‡
                const tCount = CONFIG.textLogic.transitionCount;
                const cCount = CONFIG.textLogic.carouselCount;
                
                // é˜²æ­¢æ•°ç»„è¶Šç•Œ
                if (shuffled.length >= tCount + cCount) {
                    CONFIG.transitionTexts = shuffled.slice(0, tCount);
                    CONFIG.carouselTexts = shuffled.slice(tCount, tCount + cCount);
                } else {
                    console.warn("è¯æ±‡åº“æ•°é‡ä¸è¶³ï¼Œæ— æ³•å®Œå…¨éšæœºï¼Œå›é€€åˆ°é»˜è®¤è®¾ç½®");
                }
            }
        }
        // ç«‹å³æ‰§è¡Œè¯æ±‡åˆå§‹åŒ–
        initTextLogic();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d'); 
        
        // åº”ç”¨ UI é…ç½®ä½ç½® (è¿™é‡Œç¨ååœ¨ resize ä¸­è°ƒç”¨)
        document.getElementById('touch-hint').innerText = CONFIG.ui.touchHintText;

        // [æ–°å¢] åº”ç”¨æŒ‰é’®è‡ªå®šä¹‰ä½ç½®é€»è¾‘ (Apply Custom Button Positions)
        function applyButtonPositions() {
            const posCfg = CONFIG.ui.positions;
            const mode = isMobile ? 'mobile' : 'desktop';

            // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨æ ·å¼åˆ°å…ƒç´ 
            function setStyle(elemId, cfg) {
                const el = document.getElementById(elemId);
                if (!el) return;

                // é‡ç½®æ‰€æœ‰å®šä½
                el.style.top = 'auto';
                el.style.bottom = 'auto';
                el.style.left = 'auto';
                el.style.right = 'auto';
                el.style.transform = 'none'; // é‡ç½® transform
                el.style.margin = '0';       // é‡ç½® margin

                // åº”ç”¨æ–°é…ç½®
                if (cfg.top) el.style.top = cfg.top;
                if (cfg.bottom) el.style.bottom = cfg.bottom;
                if (cfg.left) el.style.left = cfg.left;
                if (cfg.right) el.style.right = cfg.right;

                // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœ left æ˜¯ 50%ï¼Œè‡ªåŠ¨åŠ å±…ä¸­åç§»
                if (cfg.left === '50%') {
                    el.style.transform = 'translateX(-50%)';
                }
            }

            // 1. è‡ªåŠ¨çƒŸèŠ±æŒ‰é’®
            setStyle('btn-auto', posCfg.autoBtn[mode]);
            
            // 2. è¿”å›åšå®¢æŒ‰é’®
            setStyle('btn-blog', posCfg.blogBtn[mode]);

            // 3. éŸ³é‡å®¹å™¨ (æ³¨æ„ï¼šæˆ‘ä»¬å®šä½çš„æ˜¯ .volume-container ç±»)
            // å› ä¸º volume-container æ˜¯ classï¼Œè¿™é‡Œæ‰‹åŠ¨è·å–
            const volContainer = document.querySelector('.volume-container');
            if (volContainer) {
                const vCfg = posCfg.volumeBtn[mode];
                volContainer.style.top = 'auto'; volContainer.style.bottom = 'auto';
                volContainer.style.left = 'auto'; volContainer.style.right = 'auto';
                volContainer.style.transform = 'none';

                if (vCfg.top) volContainer.style.top = vCfg.top;
                if (vCfg.bottom) volContainer.style.bottom = vCfg.bottom;
                if (vCfg.left) volContainer.style.left = vCfg.left;
                if (vCfg.right) volContainer.style.right = vCfg.right;

                if (vCfg.left === '50%') {
                    volContainer.style.transform = 'translateX(-50%)';
                }
            }
        }

        // [æ–°å¢] åº”ç”¨å…è´£å£°æ˜å†…å®¹
        const disclaimerEl = document.getElementById('disclaimer');
        disclaimerEl.innerText = CONFIG.ui.disclaimer.text;
        disclaimerEl.style.color = CONFIG.ui.disclaimer.color;
        disclaimerEl.style.fontSize = CONFIG.ui.disclaimer.fontSize;

        let width, height, dpr;
        let particles = []; 
        let staticTopParticles = []; 
        let carouselGroups = [];
        let renderQueue = [];
        
        // [æ–°å¢] èƒŒæ™¯ç²’å­æ•°ç»„
        let bgParticles = [];
        
        // [æ–°å¢] çƒŸèŠ±ç›¸å…³æ•°ç»„
        let fireworks = []; // æ­£åœ¨ä¸Šå‡çš„ç«ç®­
        let sparks = [];    // çˆ†ç‚¸åçš„ç«èŠ±
        // [æ–°å¢] å°¾çƒŸæ•°ç»„
        let smokeParticles = [];

        let isMobile = false;
        let baseParticleSize = 1.8; 
        let step = 0;
        let userName = "";
        let isFinalState = false; 
        let globalRotation = 0;

        // è‡ªåŠ¨çƒŸèŠ±ç›¸å…³
        let autoFireTimer = null;
        let isAutoFiring = false;
        
        // æç¤ºè¯­çŠ¶æ€
        let hasTouchedInFinal = false;

        // ===============================================
        // ====== [é€»è¾‘] å¼€åœºåŠ¨ç”»ç®¡ç† ======
        // ===============================================
        function runIntroSequence() {
            const introLayer = document.getElementById('intro-layer');
            const introText = document.getElementById('intro-text');
            const uiLayer = document.getElementById('ui-layer');

            // 1. æ£€æŸ¥ LocalStorage å’Œé…ç½®
            const hasSeen = localStorage.getItem('hasSeenIntro_2026');
            
            // å¦‚æœæ²¡å¼€å¯ï¼Œæˆ–è€…ï¼ˆä¸æ˜¯å¼ºåˆ¶ä¸€ç›´æ˜¾ç¤º ä¸” å·²ç»çœ‹è¿‡äº†ï¼‰ï¼Œåˆ™è·³è¿‡
            if (!CONFIG.intro.enabled || (!CONFIG.intro.alwaysShow && hasSeen)) {
                introLayer.style.display = 'none';
                uiLayer.style.display = 'block';
                setTimeout(() => { uiLayer.style.opacity = 1; }, 50); // ç¨å¾®å»¶è¿Ÿè§¦å‘æ·¡å…¥
                return;
            }

            // æ ‡è®°å·²è§‚çœ‹
            localStorage.setItem('hasSeenIntro_2026', 'true');

            // 2. å¼€å§‹åŠ¨ç”»æµç¨‹
            let stepIndex = 0;
            const texts = CONFIG.intro.texts;

            function showNextText() {
                if (stepIndex >= texts.length) {
                    // åŠ¨ç”»ç»“æŸ
                    introLayer.style.opacity = 0; // å¤§é»‘å±‚æ·¡å‡º
                    setTimeout(() => {
                        introLayer.style.display = 'none'; // å½»åº•éšè—
                        uiLayer.style.display = 'block';   // æ˜¾ç¤ºè¾“å…¥æ¡†å±‚
                        setTimeout(() => { uiLayer.style.opacity = 1; }, 50); // UI æ·¡å…¥
                    }, CONFIG.intro.fadeSpeed);
                    return;
                }

                // åˆ‡æ¢æ–‡å­—
                introText.style.opacity = 0; // å…ˆéš
                setTimeout(() => {
                    introText.innerHTML = texts[stepIndex]; // æ¢å­—
                    introText.style.opacity = 1; // æ˜¾
                    
                    // åœç•™ä¸€æ®µæ—¶é—´å
                    setTimeout(() => {
                        stepIndex++;
                        showNextText(); // é€’å½’è°ƒç”¨
                    }, CONFIG.intro.duration);

                }, CONFIG.intro.fadeSpeed / 2); // æ–‡å­—åˆ‡æ¢çš„å°é—´éš™
            }

            showNextText();
        }
        
        // é¡µé¢åŠ è½½å®Œæˆåè¿è¡Œå¼€åœºé€»è¾‘
        window.addEventListener('load', runIntroSequence);

        // ===============================================
        // ====== [æ ¸å¿ƒæ–°å¢] èƒŒæ™¯éŸ³ä¹ç®¡ç†å™¨ BGM Manager ======
        // ===============================================
        const bgmManager = {
            audio: new Audio(),
            init() {
                if (!CONFIG.music.enabled || CONFIG.music.files.length === 0) return;
                
                // éšæœºé€‰ä¸€é¦–
                const randomSong = CONFIG.music.files[Math.floor(Math.random() * CONFIG.music.files.length)];
                
                this.audio.src = randomSong;
                this.audio.loop = true; // å¾ªç¯æ’­æ”¾
                this.audio.volume = CONFIG.music.volume;
                
                // é¢„åŠ è½½
                this.audio.load();
            },
            play() {
                if (!CONFIG.music.enabled) return;
                // å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’åè°ƒç”¨
                this.audio.play().catch(e => console.log("BGM autoplay prevented, waiting for interaction"));
            },
            setVolume(val) {
                this.audio.volume = Math.max(0, Math.min(1, val));
            }
        };
        // ç«‹å³åˆå§‹åŒ– BGM
        bgmManager.init();

        // ===============================================
        // ====== [æ ¸å¿ƒæ–°å¢] éŸ³æ•ˆç®¡ç†å™¨ SoundManager ======
        // ===============================================
        const soundManager = {
            ctx: null,
            buffers: {}, // ç¼“å­˜è§£ç åçš„éŸ³é¢‘æ•°æ®
            sources: CONFIG.sound.files,
            lastSmallBurstTime: 0, // ç”¨äºèŠ‚æµ

            // åˆå§‹åŒ–ï¼šå°è¯•åˆ›å»º AudioContext (éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½ resume)
            init() {
                // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬æ€»æ˜¯åˆå§‹åŒ– AudioContextï¼Œå³ä½¿ enabled æš‚æ—¶ä¸º falseï¼Œ
                // å› ä¸ºç”¨æˆ·å¯èƒ½é€šè¿‡ UI æ»‘å—ç¨åå¼€å¯å£°éŸ³ã€‚
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.preload();
                } catch (e) {
                    console.warn("Web Audio API not supported");
                }
            },

            // é¢„åŠ è½½æ‰€æœ‰éŸ³é¢‘èµ„æº
            preload() {
                if (!this.ctx) return;
                // éå†æ‰€æœ‰ç±»åˆ« (lift, burst, etc.)
                for (const [key, urls] of Object.entries(this.sources)) {
                    this.buffers[key] = [];
                    urls.forEach(url => {
                        fetch(url)
                            .then(response => response.arrayBuffer())
                            .then(arrayBuffer => this.ctx.decodeAudioData(arrayBuffer))
                            .then(decodedBuffer => {
                                this.buffers[key].push(decodedBuffer);
                            })
                            .catch(e => console.warn("Audio load failed:", url));
                    });
                }
            },

            // äº¤äº’è§£é”ï¼šæµè§ˆå™¨é€šå¸¸è¦æ±‚ç”¨æˆ·ç‚¹å‡»åæ‰èƒ½æ’­æ”¾å£°éŸ³
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // æ’­æ”¾éŸ³æ•ˆæ ¸å¿ƒé€»è¾‘
            // type: 'lift', 'burst', 'burstSmall', 'crackle'
            // scale: 0.0 ~ 1.0 (å½±å“éŸ³è°ƒå’ŒéŸ³é‡ï¼ŒçƒŸèŠ±è¶Šå°å£°éŸ³è¶Šå°–è¶Šå°)
            playSound(type, scale = 1) {
                // å¦‚æœå¼€å…³æ²¡å¼€ï¼Œæˆ–è€…éŸ³é‡ä¸º0ï¼Œå°±ä¸æ’­
                if (!CONFIG.sound.enabled && CONFIG.sound.volume <= 0.01) return;
                // æˆ–è€…æ˜¾å¼æ£€æŸ¥ enabled
                if (!CONFIG.sound.enabled && document.getElementById('sfx-slider').value <= 0) return;

                if (!this.ctx) return;

                // æ£€æŸ¥èµ„æºæ˜¯å¦åŠ è½½å®Œæ¯•
                const bufferList = this.buffers[type];
                if (!bufferList || bufferList.length === 0) return;

                // é˜²çˆ†éŸ³èŠ‚æµ (ä»…é’ˆå¯¹å°ç‚¸è£‚å£°)
                // é˜²æ­¢æ–‡å­—çƒŸèŠ±åŒæ—¶äº§ç”Ÿå¤ªå¤šå£°éŸ³å¯¼è‡´ç ´éŸ³æˆ–å¡é¡¿
                if (type === 'burstSmall') {
                    const now = Date.now();
                    if (now - this.lastSmallBurstTime < 50) return; // 50ms å†·å´
                    this.lastSmallBurstTime = now;
                }

                // éšæœºé€‰æ‹©ä¸€ä¸ªæ ·æœ¬
                const buffer = bufferList[Math.floor(Math.random() * bufferList.length)];
                
                // åˆ›å»ºéŸ³æº
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;

                // åˆ›å»ºéŸ³é‡æ§åˆ¶
                const gainNode = this.ctx.createGain();

                // ç‰©ç†æ¨¡æ‹Ÿè®¡ç®—
                // scale è¶Šå°(å°çƒŸèŠ±) -> playbackRate è¶Šå¤§(å£°éŸ³å°–), volume è¶Šå°
                // scale è¶Šå¤§(å¤§çƒŸèŠ±) -> playbackRate è¶Šå°(å£°éŸ³æ²‰), volume è¶Šå¤§
                // å‡è®¾ scale è¾“å…¥èŒƒå›´çº¦ä¸º 0.5 ~ 1.5 ä¹‹é—´
                
                // æ’­æ”¾é€Ÿåº¦ï¼šåŸºå‡† 1.0ã€‚å°çƒŸèŠ±åŠ é€Ÿï¼Œå¤§çƒŸèŠ±å‡é€Ÿã€‚
                // ç®—æ³•ï¼š1.2 - scale * 0.2 (scale=1æ—¶æ˜¯1.0ï¼Œscale=0.5æ—¶æ˜¯1.1)
                // è¿™é‡Œåšä¸€ä¸ªæ›´æ˜æ˜¾çš„æ˜ å°„
                let rate = 1.0;
                
                // [ä¿®æ”¹] ä½¿ç”¨ CONFIG.sound.volume ä½œä¸ºåŸºå‡†éŸ³é‡
                let volume = CONFIG.sound.volume;

                if (type === 'burst' || type === 'burstSmall') {
                    // é€Ÿåº¦èŒƒå›´ 0.8 (ä½æ²‰) ~ 1.5 (å°–é”)
                    rate = 1.5 - (scale * 0.5); 
                    // éŸ³é‡èŒƒå›´ 
                    volume = CONFIG.sound.volume * (0.3 + scale * 0.6);
                }

                // é™åˆ¶è¾¹ç•Œ
                rate = Math.max(0.5, Math.min(rate, 2.0));
                volume = Math.max(0.05, Math.min(volume, 1.5));

                source.playbackRate.value = rate;
                gainNode.gain.value = volume;

                // è¿æ¥èŠ‚ç‚¹ï¼šSource -> Gain -> Destination
                source.connect(gainNode);
                gainNode.connect(this.ctx.destination);

                source.start(0);
            }
        };

        // ç«‹å³åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
        soundManager.init();

        // [æ–°å¢] åˆå§‹åŒ–èƒŒæ™¯ç²’å­ (æ”¯æŒå¤šç§å½¢çŠ¶å’Œæ—‹è½¬)
        function initBackground() {
            if (!CONFIG.background.enabled) return;
            bgParticles = [];
            const count = isMobile ? CONFIG.background.countMobile : CONFIG.background.countDesktop;
            
            for (let i = 0; i < count; i++) {
                // å†³å®šå½¢çŠ¶
                let shapeType = 'circle';
                if (CONFIG.background.style === 'mix') {
                    const r = Math.random();
                    if (r < 0.4) shapeType = 'circle';      // 40% å®å¿ƒåœ†
                    else if (r < 0.7) shapeType = 'ring';   // 30% ç©ºå¿ƒåœˆ
                    else shapeType = 'cross';               // 30% åå­—æ˜Ÿ
                } else {
                    shapeType = CONFIG.background.style;
                }

                bgParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: CONFIG.background.sizeMin + Math.random() * (CONFIG.background.sizeMax - CONFIG.background.sizeMin),
                    // éšæœºé€Ÿåº¦å‘é‡ (-1 ~ 1) * speed
                    vx: (Math.random() - 0.5) * CONFIG.background.speed,
                    vy: (Math.random() - 0.5) * CONFIG.background.speed,
                    // éšæœºé€æ˜åº¦å·®å¼‚
                    alphaFactor: 0.3 + Math.random() * 0.7,
                    shape: shapeType,
                    rotation: Math.random() * Math.PI, // åˆå§‹æ—‹è½¬è§’åº¦
                    rotSpeed: (Math.random() - 0.5) * 0.02 // è‡ªè½¬é€Ÿåº¦
                });
            }
        }

        // [æ–°å¢] æ›´æ–°å¹¶ç»˜åˆ¶èƒŒæ™¯ (æ”¯æŒæ ·å¼ç»˜åˆ¶)
        function updateAndDrawBackground() {
            if (!CONFIG.background.enabled) return;
            
            ctx.fillStyle = `rgba(${CONFIG.background.color}, 1)`;
            ctx.strokeStyle = `rgba(${CONFIG.background.color}, 1)`;
            ctx.lineWidth = 1.5; // çº¿æ¡ç²—ç»†

            bgParticles.forEach(p => {
                // ç§»åŠ¨
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotSpeed; // è‡ªè½¬
                
                // è¾¹ç•Œå¾ªç¯ (å‡ºå»äº†ä»å¦ä¸€è¾¹å›æ¥)
                // ç¨å¾®ç•™ç‚¹ä½™é‡(50px)é˜²æ­¢åˆšå¥½åœ¨è¾¹ç¼˜é—ªçƒ
                if (p.x < -50) p.x = width + 50;
                if (p.x > width + 50) p.x = -50;
                if (p.y < -50) p.y = height + 50;
                if (p.y > height + 50) p.y = -50;
                
                // ç»˜åˆ¶
                ctx.globalAlpha = CONFIG.background.opacity * p.alphaFactor;
                ctx.beginPath();
                
                if (p.shape === 'circle') {
                    // å®å¿ƒåœ†
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.shape === 'ring') {
                    // ç©ºå¿ƒåœˆ (ç”»ç¨å¾®å¤§ä¸€ç‚¹ç‚¹)
                    ctx.arc(p.x, p.y, p.size * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.shape === 'cross') {
                    // åå­—æ˜Ÿ (å¸¦æ—‹è½¬)
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    const s = p.size * 1.5; 
                    ctx.moveTo(-s, 0); ctx.lineTo(s, 0);
                    ctx.moveTo(0, -s); ctx.lineTo(0, s);
                    ctx.stroke();
                    ctx.restore();
                }
            });
            
            // é‡ç½®é€æ˜åº¦ä»¥å…å½±å“åç»­ç»˜åˆ¶
            ctx.globalAlpha = 1;
        }

        function resize() {
            dpr = window.devicePixelRatio || 1;
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);
            isMobile = width < 768;
            baseParticleSize = isMobile ? 1.6 : 2.0;

            // [æ–°å¢] åŠ¨æ€åº”ç”¨æŒ‰é’®ä½ç½® (æ›¿æ¢åŸæœ‰çš„ Gap é€»è¾‘)
            applyButtonPositions();

            // [æ–°å¢] æ¯æ¬¡è°ƒæ•´çª—å£å¤§å°æ—¶é‡ç½®èƒŒæ™¯
            initBackground();
        }
        window.addEventListener('resize', resize);
        resize();

        function getRandomColor(type) {
            if (type === 'rainbow') return `hsl(${Math.random() * 360}, 90%, 65%)`;
            if (type === 'gold') return `hsl(${35 + Math.random() * 15}, 100%, 60%)`;
            if (type === 'red') return `hsl(${340 + Math.random() * 20}, 100%, 60%)`;
            if (type === 'white') return `hsl(0, 0%, 95%)`; 
            return `hsl(45, 100%, 60%)`; 
        }

        class Particle {
            constructor(x, y) {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.tx = x;
                this.ty = y;
                this.relX = 0;
                this.relY = 0;
                this.color = getRandomColor('gold'); 
                this.alpha = 1;

                this.isTwinkler = CONFIG.twinkle.enabled && (Math.random() < CONFIG.twinkle.probability);
                this.twinklePhase = Math.random() * Math.PI * 2;
                this.twinkleSpeed = CONFIG.twinkle.speedMin + Math.random() * (CONFIG.twinkle.speedMax - CONFIG.twinkle.speedMin);
            }

            update() {
                this.x += (this.tx - this.x) * CONFIG.particleEase;
                this.y += (this.ty - this.y) * CONFIG.particleEase;
                
                if (this.isTwinkler) {
                    this.twinklePhase += this.twinkleSpeed;
                }
            }

            draw(scale = 1, forceX = null, forceY = null, baseAlpha = 1) {
                let currentAlpha = this.alpha * baseAlpha;

                // é”åŒ–çš„å‘¼å¸ç®—æ³•
                if (this.isTwinkler) {
                    const rawSin = Math.sin(this.twinklePhase);
                    const normalizedWave = (rawSin + 1) / 2;
                    const sharpWave = Math.pow(normalizedWave, CONFIG.twinkle.sharpness);
                    const range = CONFIG.twinkle.maxOpacity - CONFIG.twinkle.minOpacity;
                    const twinkleFactor = CONFIG.twinkle.minOpacity + sharpWave * range;
                    currentAlpha *= twinkleFactor;
                }
                
                currentAlpha *= CONFIG.visuals.alphaFactor;

                if (currentAlpha < 0.01) return;

                if (CONFIG.visuals.globalAdditive) {
                    ctx.globalCompositeOperation = 'lighter';
                } else if (this.isTwinkler && CONFIG.visuals.twinkleAdditive) {
                    // ä»…åœ¨æ³¢å³°é«˜äº®æ—¶å¯ç”¨å åŠ 
                    if (currentAlpha > 0.3) {
                           ctx.globalCompositeOperation = 'lighter';
                    } else {
                           ctx.globalCompositeOperation = 'source-over';
                    }
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }

                ctx.globalAlpha = currentAlpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                const drawX = forceX !== null ? forceX : this.x;
                const drawY = forceY !== null ? forceY : this.y;
                let s = baseParticleSize * scale;
                s = Math.max(0.5, Math.min(s, baseParticleSize * 4)); 
                ctx.arc(drawX, drawY, s, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.globalCompositeOperation = 'source-over'; 
                ctx.globalAlpha = 1;
            }
        }

        // ä¿®æ”¹æ ¸å¿ƒï¼šæ”¯æŒå°æ•°æ­¥é•¿ (Density Control Logic Upgrade)
        function sampleText(text, targetFontSize, colorType = 'gold', stepOverride = null) {
            const tmpCanvas = document.createElement('canvas');
            const tCtx = tmpCanvas.getContext('2d');
            tCtx.font = `bold ${targetFontSize}px "Microsoft YaHei", sans-serif`;
            const measure = tCtx.measureText(text);
            let finalSize = targetFontSize;
            const maxW = width * 0.9; 
            if (measure.width > maxW) finalSize = targetFontSize * (maxW / measure.width);
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            tCtx.font = `bold ${finalSize}px "Microsoft YaHei", sans-serif`;
            tCtx.fillStyle = "white";
            tCtx.textAlign = "center";
            tCtx.textBaseline = "middle";
            tCtx.fillText(text, width / 2, height / 2);
            const idata = tCtx.getImageData(0, 0, width, height);
            const data = idata.data;
            const points = [];
            
            // ç¡®å®šé‡‡æ ·æ­¥é•¿
            let currentStep;
            if (stepOverride) {
                currentStep = stepOverride;
            } else {
                currentStep = isMobile ? CONFIG.density.introMobile : CONFIG.density.introDesktop;
            }
            
            // æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ Math.floor æ”¯æŒæµ®ç‚¹æ•°åæ ‡é‡‡æ ·
            for (let y = 0; y < height; y += currentStep) {
                for (let x = 0; x < width; x += currentStep) {
                    // å°†æµ®ç‚¹åæ ‡å–æ•´ï¼Œæ˜ å°„åˆ°åƒç´ æ•°ç»„ç´¢å¼•
                    const inY = Math.floor(y);
                    const inX = Math.floor(x);
                    
                    // è¾¹ç•Œæ£€æŸ¥ï¼Œé˜²æ­¢å°æ•°ç´¯åŠ å¯¼è‡´çš„æº¢å‡º
                    if (inY >= height || inX >= width) continue;

                    if (data[(inY * width + inX) * 4 + 3] > 128) {
                        points.push({ x: inX, y: inY, colorType: colorType });
                    }
                }
            }
            return points;
        }

        // [ç§»æ¤ä¿®æ”¹] æ–°å¢ï¼šé«˜æ•ˆçš„æ–‡å­—ç‚¹é˜µè·å–å‡½æ•° (æºè‡ª MyMath.literalLattice)
        // ä¸“é—¨ç”¨äºçƒŸèŠ±æ–‡å­—ï¼Œæ€§èƒ½æ¯” sampleText æ›´å¥½ï¼Œä¸”åªç”Ÿæˆæ–‡å­—åŒºåŸŸçš„ç‚¹
        function getTextLattice(text, fontSize) {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ç¦»å± canvas
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            const fontFamily = '"Microsoft YaHei", sans-serif';

            // 1. å…ˆè®¾ç½®å­—ä½“æ¥æµ‹é‡å®½åº¦
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            const measure = ctx.measureText(text);
            const width = Math.ceil(measure.width);
            const height = fontSize + 20; // ç»™ä¸€ç‚¹é«˜åº¦å†—ä½™é˜²æ­¢è¢«æˆªæ–­

            // 2. è°ƒæ•´ canvas å¤§å°ä¸ºæ–‡å­—å®é™…å¤§å°
            canvas.width = width;
            canvas.height = height;

            // 3. é‡æ–°è®¾ç½®å­—ä½“ (è°ƒæ•´å¤§å°åéœ€è¦é‡è®¾)
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            ctx.fillStyle = "#ffffff";
            ctx.textBaseline = "middle";
            ctx.textAlign = "left"; // å·¦å¯¹é½æ–¹ä¾¿æ‰«æ

            // 4. ç»˜åˆ¶æ–‡å­—
            ctx.fillText(text, 0, height / 2);

            // 5. è·å–åƒç´ æ•°æ®
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const points = [];

            // 6. é‡‡æ ·å¯†åº¦ (æ ¹æ®è®¾å¤‡è°ƒæ•´ï¼Œæ‰‹æœºç¨€ç–ä¸€ç‚¹)
            // å¯¹åº” user config ä¸­çš„ density æ¦‚å¿µï¼Œä½†è¿™é‡Œæ˜¯å±€éƒ¨é‡‡æ ·
            const density = isMobile ? 2 : 3;

            for (let y = 0; y < height; y += density) {
                for (let x = 0; x < width; x += density) {
                    const i = (y * width + x) * 4;
                    // alpha > 128 è®¤ä¸ºæ˜¯æ–‡å­—éƒ¨åˆ†
                    if (data[i + 3] > 128) {
                        points.push({ x: x, y: y });
                    }
                }
            }

            return {
                width: width,
                height: height,
                points: points
            };
        }

        function createFinalStage() {
            isFinalState = true;
            particles = []; staticTopParticles = []; carouselGroups = [];

            // [ä¿®æ”¹] åªæ˜¾ç¤ºåŸæœ¬è¢«éšè—çš„æŒ‰é’®ï¼ŒéŸ³é‡æŒ‰é’®ä¸€ç›´éƒ½åœ¨
            const hiddenBtns = document.querySelectorAll('.initially-hidden');
            hiddenBtns.forEach(btn => {
                btn.classList.add('reveal-btn');
            });
            
            // [æ–°å¢] æ˜¾ç¤ºæˆ³æˆ³å±å¹•æç¤º
            if (!hasTouchedInFinal) {
                document.getElementById('touch-hint').style.opacity = 1;
            }

            let topY_Center = height * 0.15; 
            let midY_Center = height * 0.30; 
            let botY_Center = height * 0.45; 
            
            // è·å–é…ç½®çš„å­—ä½“å¤§å°
            let titleSize = isMobile ? CONFIG.fontSizes.finalTitleMobile : CONFIG.fontSizes.finalTitleDesktop;
            let nameSize = isMobile ? CONFIG.fontSizes.finalNameMobile : CONFIG.fontSizes.finalNameDesktop;
            let yearSize = isMobile ? CONFIG.fontSizes.finalYearMobile : CONFIG.fontSizes.finalYearDesktop;
            
            // è·å– Final é˜¶æ®µçš„å¯†åº¦
            const finalStep = isMobile ? CONFIG.density.finalMobile : CONFIG.density.finalDesktop;

            const p1 = sampleText("ç¥", titleSize, 'red', finalStep);
            const p2 = sampleText(userName, nameSize, 'gold', finalStep);
            const p3 = sampleText("2026", yearSize, 'gold', finalStep);

            [...p1, ...p2, ...p3].forEach(p => {
                let part = new Particle(width/2, height/2);
                let targetY = 0;
                if (p1.includes(p)) targetY = p.y - (height/2) + topY_Center;
                else if (p2.includes(p)) targetY = p.y - (height/2) + midY_Center;
                else targetY = p.y - (height/2) + botY_Center;
                part.tx = p.x; part.ty = targetY;
                let cType = 'gold'; if (p1.includes(p)) cType = 'red';
                part.color = getRandomColor(cType);
                part.x = width/2 + (Math.random()-0.5) * 300; 
                part.y = height/2 + (Math.random()-0.5) * 300;
                staticTopParticles.push(part);
            });

            let carouselSize = isMobile ? CONFIG.fontSizes.carouselMobile : CONFIG.fontSizes.carouselDesktop;
            let list = CONFIG.carouselTexts;
            let angleStep = (Math.PI * 2) / list.length;
            
            list.forEach((text, index) => {
                const points = sampleText(text, carouselSize, 'rainbow', finalStep);
                let group = {
                    baseAngle: index * angleStep,
                    parts: []
                };
                points.forEach(p => {
                    let part = new Particle(width/2, height + 200);
                    part.relX = -(p.x - width / 2); 
                    part.relY = p.y - height / 2;
                    part.x = (Math.random()-0.5) * width * 1.5; 
                    part.y = height + 200;
                    part.color = getRandomColor('rainbow');
                    group.parts.push(part);
                });
                carouselGroups.push(group);
            });
        }

        function updateMainText(text) {
            let size = isMobile ? CONFIG.fontSizes.introMobile : CONFIG.fontSizes.introDesktop;
            // å¦‚æœåå­—å¤ªé•¿ï¼Œè‡ªåŠ¨ç¼©å°ä¸€ç‚¹
            if(text.length > 4) size *= 0.7;
            
            const introStep = isMobile ? CONFIG.density.introMobile : CONFIG.density.introDesktop;
            const points = sampleText(text, size, 'gold', introStep);
            
            if (particles.length < points.length) {
                for(let i=0; i<points.length-particles.length; i++) particles.push(new Particle(width/2, height/2));
            } else {
                for(let i=points.length; i<particles.length; i++) particles[i].alpha = 0;
            }
            
            let targetColorMode = CONFIG.textColors.initialMode;
            if (CONFIG.textColors.randomize) {
                const modes = ['gold', 'red', 'rainbow', 'white'];
                targetColorMode = modes[Math.floor(Math.random() * modes.length)];
            }

            points.sort(() => Math.random()-0.5);
            particles.forEach((p, i) => {
                if (i < points.length) {
                    p.tx = points[i].x; 
                    p.ty = points[i].y; 
                    p.alpha = 1; 
                    p.color = getRandomColor(targetColorMode);
                }
            });
        }

        function startShow() {
            const input = document.getElementById('nameInput');
            if (!input.value) return;
            
            // [æ–°å¢] ç”¨æˆ·äº¤äº’è§¦å‘éŸ³é¢‘è§£é” (iOS/Chrome ç­–ç•¥è¦æ±‚)
            soundManager.resume();
            
            // [æ–°å¢] å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹
            bgmManager.play();

            userName = input.value;
            document.getElementById('ui-layer').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('hint').style.opacity = 1;
            }, 500);
            updateMainText(userName);
            window.addEventListener('mousedown', handleClick);
            window.addEventListener('touchstart', handleClick, {passive: false});
            animate();
        }

        function explodeAndSwitch(nextText) {
            let targets = isFinalState ? staticTopParticles : particles;
            targets.forEach(p => {
                let dx = p.x - width/2; let dy = p.y - height/2;
                p.tx += dx * 0.8; p.ty += dy * 0.8;
            });
            setTimeout(() => {
                if (nextText === "FINAL") createFinalStage(); else updateMainText(nextText);
            }, 300);
        }

        // ===============================================
        // ====== [æ–°å¢åŠŸèƒ½] çƒŸèŠ±é€»è¾‘ (Fireworks Logic) ======
        // ===============================================

        // [æ–°å¢] åˆ›å»ºå°¾çƒŸç²’å­
        function createSmoke(x, y) {
            if (!CONFIG.fireworks.smoke.enabled) return;
            
            const size = isMobile ? CONFIG.fireworks.smoke.sizeMobile : CONFIG.fireworks.smoke.sizeDesktop;
            smokeParticles.push({
                x: x + (Math.random() - 0.5) * CONFIG.fireworks.smoke.jitter * 5,
                y: y,
                size: size,
                alpha: 0.5, // åˆå§‹é€æ˜åº¦
                vx: (Math.random() - 0.5) * 0.3, // è½»å¾®é£˜åŠ¨
                vy: (Math.random() * 0.5),       // è½»å¾®ä¸‹æ²‰
                decay: CONFIG.fireworks.smoke.decaySpeed
            });
        }

        // [æ–°å¢] æ›´æ–°å¹¶ç»˜åˆ¶å°¾çƒŸ
        function updateAndDrawSmoke() {
            if (!CONFIG.fireworks.smoke.enabled) return;

            ctx.fillStyle = `rgba(${CONFIG.fireworks.smoke.color}, 1)`;
            
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                let s = smokeParticles[i];
                s.x += s.vx;
                s.y += s.vy;
                s.alpha -= s.decay;
                
                if (s.alpha <= 0) {
                    smokeParticles.splice(i, 1);
                    continue;
                }
                
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function launchFirework(targetX, targetY) {
            // [æ–°å¢] è§¦å‘å‘å°„éŸ³æ•ˆ (lift)
            soundManager.playSound('lift', 1);

            // å‘å°„ä¸€ä¸ªâ€œç«ç®­â€
            const speed = isMobile ? CONFIG.fireworks.launchSpeedMobile : CONFIG.fireworks.launchSpeedDesktop;
            fireworks.push({
                x: targetX, // ä»ç‚¹å‡»çš„Xè½´æ­£ä¸‹æ–¹å‘å°„ (åˆå§‹X)
                baseX: targetX, // è®°å½•åŸºå‡†çº¿ï¼Œç”¨äºè®¡ç®—æŠ–åŠ¨
                y: height,  // å±å¹•åº•éƒ¨
                tx: targetX,
                ty: targetY,
                speed: speed,
                color: getRandomColor('rainbow'), // éšæœºé¢œè‰²
                wobblePhase: Math.random() * Math.PI * 2, // åˆå§‹æŠ–åŠ¨ç›¸ä½
                tick: 0 // ç”¨äºæ§åˆ¶å°¾çƒŸç”Ÿæˆé¢‘ç‡
            });
        }

        // [å‡çº§] çˆ†ç‚¸é€»è¾‘ - æ”¯æŒå›¾æ¡ˆå’Œæ–‡å­—
        function createExplosion(x, y, color) {
            // 1. åˆ¤æ–­æ˜¯å¦è§¦å‘æ–‡å­—çƒŸèŠ± (æ¦‚ç‡è§¦å‘)
            const textCfg = CONFIG.fireworks.textFireworks;
            if (textCfg.enabled && Math.random() < textCfg.probability) {
                createWordExplosion(x, y);
                return; // â˜… å¦‚æœæ˜¯æ–‡å­—çƒŸèŠ±ï¼Œå°±ä¸è¦å†äº§ç”Ÿæ™®é€šç«èŠ±äº†
            }

            // 2. å¦‚æœä¸æ˜¯æ–‡å­—ï¼Œåˆ™ä½¿ç”¨å‡ ä½•å›¾æ¡ˆçˆ†ç‚¸
            const count = isMobile ? CONFIG.fireworks.explosionCountMobile : CONFIG.fireworks.explosionCountDesktop;
            const scaleMul = isMobile ? CONFIG.fireworks.patterns.scaleMobile : CONFIG.fireworks.patterns.scaleDesktop;
            
            // [æ–°å¢] è§¦å‘æ™®é€šçˆ†ç‚¸éŸ³æ•ˆ (burst)
            // æ ¹æ® scaleMul è°ƒæ•´éŸ³è°ƒã€‚scaleMul è¶Šå¤§ï¼Œscale è¶Šå¤§ï¼Œå£°éŸ³è¶Šä½æ²‰ã€‚
            // è¿™é‡Œå°† scaleMul å½’ä¸€åŒ–åˆ° 0.8~1.2 å·¦å³ä¼ ç»™ playSound
            soundManager.playSound('burst', isMobile ? scaleMul / 1.5 : scaleMul / 2.0);

            // å†³å®šå½“å‰è¿™ä¸ªçƒŸèŠ±çš„å½¢çŠ¶
            let patternType = 'sphere'; // é»˜è®¤åœ†å½¢
            if (CONFIG.fireworks.patterns.enabled) {
                const r = Math.random();
                if (r < 0.5) patternType = 'sphere';        // 50% æ­£å¸¸åœ†å½¢
                else if (r < 0.75) patternType = 'ring';    // 25% ç¯å½¢
                else patternType = 'burst';                 // 25% ç‚¸è£‚æ˜Ÿå½¢
            }

            for (let i = 0; i < count; i++) {
                let angle, speed;

                if (patternType === 'ring') {
                    // ç¯å½¢ï¼šè§’åº¦éšæœºï¼Œé€Ÿåº¦å›ºå®š
                    angle = Math.random() * Math.PI * 2;
                    speed = CONFIG.fireworks.explosionForce * 0.8 * scaleMul; // ç¯å½¢ç¨å¾®æ•´é½ç‚¹
                } else if (patternType === 'burst') {
                    // æ˜Ÿå½¢ï¼šåˆ†å‡ æŸ
                    const arms = 8;
                    const armAngle = (Math.PI * 2) / arms;
                    const fuzzy = (Math.random() - 0.5) * 0.5; // ç¨å¾®æ•£å¼€ç‚¹
                    const baseAngle = Math.floor(Math.random() * arms) * armAngle;
                    angle = baseAngle + fuzzy;
                    speed = Math.random() * CONFIG.fireworks.explosionForce * 1.2 * scaleMul;
                } else {
                    // é»˜è®¤çƒå½¢ï¼šå®Œå…¨éšæœº
                    angle = Math.random() * Math.PI * 2;
                    speed = Math.random() * CONFIG.fireworks.explosionForce * scaleMul;
                }

                sparks.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    alpha: 1,
                    decay: CONFIG.fireworks.decayMin + Math.random() * (CONFIG.fireworks.decayMax - CONFIG.fireworks.decayMin), 
                    color: color,
                    isText: false // æ ‡è®°è¿™ä¸æ˜¯æ–‡å­—ç²’å­
                });
            }
        }

        // [ä¿®æ”¹] æ–‡å­—çˆ†ç‚¸é€»è¾‘ - å‡çº§ç‰ˆï¼šç”±ä¸­å¿ƒå‘å¤–ç‚¸å¼€ (ä½¿ç”¨ç§»æ¤çš„ getTextLattice ç®—æ³•)
        function createWordExplosion(cx, cy) {
            // [æ–°å¢] è§¦å‘æ–‡å­—çƒŸèŠ±éŸ³æ•ˆ (burstSmall)
            // æ–‡å­—çƒŸèŠ±é€šå¸¸å¯†é›†ï¼Œä½¿ç”¨èŠ‚æµçš„ burstSmall
            soundManager.playSound('burstSmall', 1.0);

            const cfg = CONFIG.fireworks.textFireworks;
            const word = cfg.words[Math.floor(Math.random() * cfg.words.length)];
            
            // å­—ä½“å¤§å° (å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ï¼Œå› ä¸ºç¦»å± Canvas ä¸å—å±å¹•é™åˆ¶)
            const fontSize = isMobile ? 60 : 100; 
            
            // [ç§»æ¤] ä½¿ç”¨æ–°å‡½æ•°è·å–ç‚¹é˜µï¼Œæ›¿æ¢åŸæ¥çš„ sampleText è°ƒç”¨
            // è¿™é‡Œçš„ lattice åŒ…å« {width, height, points: [{x,y}]}
            const lattice = getTextLattice(word, fontSize);
            
            // [NEW] ç¡®å®šæ–‡å­—é¢œè‰² - ä¿è¯å•å­—çº¯è‰²
            let explosionColor = 'hsl(45, 100%, 60%)'; // é»˜è®¤é‡‘
            if (cfg.colorMode === 'random') {
                // éšæœºå–ä¸€ä¸ªå½©è™¹è‰²ï¼Œä½†å…¨å­—ç»Ÿä¸€
                explosionColor = getRandomColor('rainbow');
            } else if (cfg.colorMode === 'fixed') {
                explosionColor = `rgb(${cfg.fixedColor})`;
            } else {
                // 'gold'
                explosionColor = getRandomColor('gold');
            }

            // [NEW] è·å–ç‚¸å¼€åŠ›åº¦æ¯”ä¾‹
            const scaleForce = isMobile ? cfg.explosionScaleMobile : cfg.explosionScaleDesktop;

            // è®¡ç®—ä¸­å¿ƒåç§»é‡ï¼Œè®©æ–‡å­—åœ¨ cx, cy å¤„å±…ä¸­ç‚¸å¼€
            const centerX = lattice.width / 2;
            const centerY = lattice.height / 2;

            lattice.points.forEach(p => {
                // p.x, p.y æ˜¯åœ¨å° canvas é‡Œçš„åæ ‡
                // éœ€è¦è®¡ç®—ç›¸å¯¹äºæ–‡å­—ä¸­å¿ƒçš„åç§»
                const relX = p.x - centerX;
                const relY = p.y - centerY;
                
                sparks.push({
                    x: cx, 
                    y: cy,
                    // é€Ÿåº¦ = è·ç¦» * ç³»æ•°ã€‚è¿™æ ·è¿œçš„ç²’å­é£å¾—å¿«ï¼Œè¿‘çš„é£å¾—æ…¢ï¼Œæœ€ç»ˆåŒæ—¶åˆ°è¾¾å½¢çŠ¶
                    // 0.08 æ˜¯ä¸ªç»éªŒç³»æ•°ï¼Œè®©å®ƒç‚¸å¾—è‡ªç„¶ç‚¹
                    vx: relX * scaleForce * 0.08, 
                    vy: relY * scaleForce * 0.08,
                    alpha: 1,
                    decay: cfg.decaySpeed, // æ–‡å­—æ¶ˆå¤±å¾—æ…¢ä¸€ç‚¹
                    color: explosionColor, // ä½¿ç”¨ç»Ÿä¸€é¢œè‰²
                    isText: true, // æ ‡è®°ä¸ºæ–‡å­—ç²’å­
                    size: isMobile ? cfg.particleSizeMobile : cfg.particleSizeDesktop
                });
            });
        }

        function updateAndDrawFireworks() {
            // [æ–°å¢] å…ˆç”»å°¾çƒŸï¼Œè®©å®ƒåœ¨ç«èŠ±ä¸‹é¢
            updateAndDrawSmoke();

            // 1. æ›´æ–°ä¸Šå‡çš„çƒŸèŠ±
            for (let i = fireworks.length - 1; i >= 0; i--) {
                let fw = fireworks[i];
                fw.y -= fw.speed;
                
                // [æ–°å¢] è®¡ç®—é£è¡ŒæŠ–åŠ¨ (Så‹ä¸Šå‡)
                fw.wobblePhase += 0.15; // æŠ–åŠ¨é¢‘ç‡
                const wobbleOffset = Math.sin(fw.wobblePhase) * CONFIG.fireworks.ascentWobble;
                const currentX = fw.baseX + wobbleOffset;
                fw.x = currentX;

                // [æ–°å¢] ç”Ÿæˆå°¾çƒŸ
                fw.tick++;
                if (fw.tick % CONFIG.fireworks.smoke.interval === 0) {
                    createSmoke(currentX, fw.y + 10); // åœ¨ç«ç®­å°¾éƒ¨ç”Ÿæˆ
                }

                // ç»˜åˆ¶æ‹–å°¾
                ctx.beginPath();
                // æ‹–å°¾ä¹Ÿç¨å¾®å¸¦ç‚¹æŠ–åŠ¨æ„Ÿ
                ctx.moveTo(currentX, fw.y + fw.speed * 1.5);
                ctx.lineTo(currentX, fw.y);
                ctx.strokeStyle = fw.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // åˆ°è¾¾ç›®æ ‡é«˜åº¦ï¼Ÿçˆ†ç‚¸ï¼
                if (fw.y <= fw.ty) {
                    createExplosion(fw.baseX, fw.y, fw.color); // åœ¨åŸºå‡†Xå¤„çˆ†ç‚¸ï¼Œé˜²æ­¢åç¦»
                    fireworks.splice(i, 1);
                }
            }

            // 2. æ›´æ–°çˆ†ç‚¸çš„ç«èŠ±
            for (let i = sparks.length - 1; i >= 0; i--) {
                let s = sparks[i];
                s.x += s.vx;
                s.y += s.vy;
                
                // æ–‡å­—ç²’å­å—é‡åŠ›å½±å“å°ä¸€ç‚¹ï¼Œå¦åˆ™å­—ä¼šæ²‰ä¸‹å»
                if (s.isText) {
                      s.vy += CONFIG.fireworks.gravity * 0.3; 
                      s.vx *= 0.92; // æ–‡å­—ç²’å­é˜»åŠ›å¤§ï¼Œä¸ºäº†ä¿æŒå½¢çŠ¶
                      s.vy *= 0.92;
                } else {
                      s.vy += CONFIG.fireworks.gravity; 
                      s.vx *= CONFIG.fireworks.friction; 
                      s.vy *= CONFIG.fireworks.friction;
                }
                
                s.alpha -= s.decay;

                if (s.alpha <= 0) {
                    sparks.splice(i, 1);
                } else {
                    ctx.globalAlpha = s.alpha;
                    ctx.fillStyle = s.color;
                    ctx.beginPath();
                    // æ–‡å­—ç²’å­å¤§å°å¯æ§ï¼Œæ™®é€šç²’å­ç”¨åŸæ¥çš„å¤§å°
                    let pSize = s.isText ? s.size : (isMobile ? 1.5 : 2);
                    ctx.arc(s.x, s.y, pSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1; // æ¢å¤
        }

        // ===============================================
        // ====== [æ–°å¢åŠŸèƒ½] UI äº¤äº’é€»è¾‘ ======
        // ===============================================

        function toggleAutoFire() {
            const btn = document.getElementById('btn-auto');
            if (isAutoFiring) {
                isAutoFiring = false;
                btn.innerText = "è‡ªåŠ¨æ”¾çƒŸèŠ±: å…³";
                btn.classList.remove('active');
                clearTimeout(autoFireTimer);
            } else {
                isAutoFiring = true;
                btn.innerText = "è‡ªåŠ¨æ”¾çƒŸèŠ±: å¼€";
                btn.classList.add('active');
                scheduleNextFirework();
            }
        }

        function scheduleNextFirework() {
            if (!isAutoFiring) return;
            const delay = CONFIG.ui.autoFire.minInterval + Math.random() * (CONFIG.ui.autoFire.maxInterval - CONFIG.ui.autoFire.minInterval);
            autoFireTimer = setTimeout(() => {
                if (!isAutoFiring) return;
                
                // [æ–°å¢] æ”¯æŒå¹¶å‘ (ä¸€æ¬¡æ”¾å¥½å‡ ä¸ª)
                const burstCount = Math.floor(Math.random() * CONFIG.ui.autoFire.maxConcurrent) + 1;
                
                for(let k=0; k<burstCount; k++) {
                    const targetX = width * 0.1 + Math.random() * width * 0.8;
                    const targetY = height * 0.1 + Math.random() * height * 0.4; // åä¸Šæ–¹ç‚¸
                    launchFirework(targetX, targetY);
                }
                
                scheduleNextFirework();
            }, delay);
        }

        function reloadPage() {
            location.reload();
        }

        function goBlog() {
            window.location.href = CONFIG.ui.blogUrl;
        }

        // [ä¿®æ”¹] éŸ³é‡ UI äº¤äº’å‡½æ•° - æ§åˆ¶ç«–å‘é¢æ¿æ˜¾ç¤º
        function toggleVolumePanel() {
            const panel = document.getElementById('volume-panel-vertical');
            panel.classList.toggle('show');
        }

        function updateBgmVolume(val) {
            CONFIG.music.volume = parseFloat(val);
            bgmManager.setVolume(CONFIG.music.volume);
        }

        function updateSfxVolume(val) {
            CONFIG.sound.volume = parseFloat(val);
            // é¡ºä¾¿å¦‚æœéŸ³é‡å¤§äº0ï¼Œå¼€å¯éŸ³æ•ˆ enabledï¼Œå¦åˆ™å…³é—­ï¼Œä¼˜åŒ–æ€§èƒ½
            CONFIG.sound.enabled = (CONFIG.sound.volume > 0.01);
        }

        // ===============================================

        let isAnimating = false;
        function handleClick(e) {
            // [æ–°å¢] äº¤äº’æ—¶å°è¯•è§£é” AudioContext
            soundManager.resume();

            // æ’é™¤ç‚¹å‡»åˆ°åº•éƒ¨æŒ‰é’®å’ŒéŸ³é‡æ§ä»¶çš„æƒ…å†µ
            // ä½¿ç”¨ closest æ£€æŸ¥ç‚¹å‡»æ˜¯å¦å‘ç”Ÿåœ¨ button æˆ– .volume-container å†…éƒ¨
            if (e.target.tagName === 'BUTTON' || e.target.closest('.volume-container') || e.target.tagName === 'INPUT') return;
            
            if (e.type === 'touchstart') e.preventDefault();
            
            let clientX, clientY;
            if (e.type === 'touchstart') {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // [æ–°å¢] åº•éƒ¨è¯¯è§¦ä¿æŠ¤é€»è¾‘
            // å¦‚æœç‚¹å‡»ä½ç½®è·ç¦»åº•éƒ¨å¤ªè¿‘ï¼Œç›´æ¥å¿½ç•¥ï¼ˆä¸æ”¾çƒŸèŠ±ï¼Œä¹Ÿä¸åˆ‡æ¢åœºæ™¯ï¼‰
            // è¿™æ ·ç”¨æˆ·åœ¨ç‚¹æŒ‰é’®æ‰‹æŠ–ç‚¹åæ—¶ï¼Œä¸ä¼šè¯¯è§¦å‘çƒŸèŠ±
            const safeZone = isMobile ? CONFIG.ui.safeZoneHeightMobile : CONFIG.ui.safeZoneHeightDesktop;
            if (height - clientY < safeZone) {
                return; 
            }
            
            // [æ–°å¢] å¦‚æœæ˜¯æœ€ç»ˆçŠ¶æ€ï¼Œç‚¹å‡»å°±æ˜¯æ”¾çƒŸèŠ±
            if (isFinalState) {
                // ç¬¬ä¸€æ¬¡ç‚¹å‡»åï¼Œéšè—æç¤ºè¯­
                if (!hasTouchedInFinal) {
                    hasTouchedInFinal = true;
                    document.getElementById('touch-hint').style.opacity = 0;
                }
                launchFirework(clientX, clientY);
                return; // è¿™é‡Œçš„ return å¾ˆé‡è¦ï¼Œé˜»æ­¢è§¦å‘åé¢çš„åœºæ™¯åˆ‡æ¢é€»è¾‘
            }

            if (isAnimating) return;
            isAnimating = true; step++;
            document.getElementById('hint').style.opacity = 0;
            if (step <= CONFIG.transitionTexts.length) {
                explodeAndSwitch(CONFIG.transitionTexts[step-1]);
                setTimeout(() => {
                    isAnimating = false; document.getElementById('hint').style.opacity = 1;
                }, 1800);
            } else {
                explodeAndSwitch("FINAL");
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            // [æ–°å¢] åœ¨æ¸…ç©ºç”»å¸ƒåã€ç»˜åˆ¶ä¸»è¦æ–‡å­—å‰ï¼Œå…ˆç”»èƒŒæ™¯
            // è¿™æ ·èƒŒæ™¯æ°¸è¿œåœ¨æœ€åé¢ï¼Œä¸ä¼šé®æŒ¡æ–‡å­—
            updateAndDrawBackground();

            // [æ–°å¢] ç»˜åˆ¶çƒŸèŠ±ï¼ˆå»ºè®®æ”¾åœ¨èƒŒæ™¯ä¹‹ä¸Šï¼Œæ–‡å­—ä¹‹ä¸‹ï¼Œæˆ–è€…æ–‡å­—ä¹‹ä¸Šéƒ½å¯ä»¥ï¼‰
            // è¿™é‡Œæ”¾åœ¨æ–‡å­—å±‚ä¸‹é¢ä¸€ç‚¹ç‚¹ï¼Œæˆ–è€…ç”¨ lighter æ··åˆæ¨¡å¼è®©å®ƒæ›´äº®
            ctx.globalCompositeOperation = 'lighter';
            updateAndDrawFireworks();
            ctx.globalCompositeOperation = 'source-over'; 

            if (!isFinalState) {
                particles.forEach(p => { 
                    p.update(); 
                    if(p.alpha > 0.01) p.draw(1); 
                });
            } else {
                staticTopParticles.forEach(p => { 
                    p.update(); 
                    p.draw(1); 
                });

                globalRotation -= CONFIG.rotationSpeed;
                
                const radius = isMobile ? width * CONFIG.carouselRadiusRatioMobile : width * CONFIG.carouselRadiusRatioDesktop;
                const targetCenterRatio = isMobile ? CONFIG.centerYMobile : CONFIG.centerYDesktop;
                const centerY = height * targetCenterRatio; 
                const fov = isMobile ? CONFIG.fovMobile : CONFIG.fovDesktop;
                const tiltFactor = isMobile ? CONFIG.tiltFactorMobile : CONFIG.tiltFactorDesktop;

                renderQueue = [];

                carouselGroups.forEach(group => {
                    const angle = group.baseAngle + globalRotation;
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);

                    group.parts.forEach(p => {
                        p.update(); 
                        const x3d = p.relX * cosA + radius * sinA;
                        const z3d = -p.relX * sinA + radius * cosA;
                        const scale = fov / (fov + z3d);
                        const screenX = width / 2 + x3d * scale;
                        const screenY = centerY + (p.relY * scale) - (z3d * tiltFactor * scale);
                        
                        let progress = (radius * 1.1 - z3d) / (2 * radius * 1.1);
                        progress = Math.max(0, Math.min(1, progress));
                        let alpha = Math.pow(progress, 3.5); 

                        if (scale > 0.1 && alpha > 0.005) {
                             renderQueue.push({
                                 particle: p,
                                 scale: scale,
                                 x: screenX,
                                 y: screenY,
                                 alpha: alpha,
                                 z: z3d
                             });
                        }
                    });
                });

                renderQueue.sort((a, b) => b.z - a.z);

                renderQueue.forEach(item => {
                    item.particle.draw(item.scale, item.x, item.y, item.alpha);
                });
            }
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>