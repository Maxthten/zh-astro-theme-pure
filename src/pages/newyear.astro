---
// src/pages/newyear.astro
---

<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>2026æ–°å¹´ç¥ç¦</title>
    
    <script is:inline src="/scripts/lz-string.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Microsoft YaHei', sans-serif; touch-action: none; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* ============================================================ */
        /* ====== å¼€åœºåŠ¨ç”»å±‚ (Intro Layer) ====== */
        /* ============================================================ */
        #intro-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #000;
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            color: rgba(255, 255, 255, 0.9);
            font-size: 24px; letter-spacing: 4px; font-weight: 300;
            pointer-events: none;
            opacity: 1;
            transition: opacity 1s;
        }
        
        .breathing {
            animation: breathe 3s ease-in-out infinite;
        }
        @keyframes breathe {
            0% { opacity: 0.3; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); text-shadow: 0 0 15px rgba(255,255,255,0.5); }
            100% { opacity: 0.3; transform: scale(0.95); }
        }

        .error-style {
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.8);
            line-height: 1.5;
        }

        /* ============================================================ */
        /* ====== UIå±‚ UI Layer (Input) ====== */
        /* ============================================================ */
        #ui-layer {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; z-index: 10;
            transition: opacity 0.5s;
            width: 100%;
            pointer-events: auto;
            opacity: 0; 
            display: none;
        }
        
        input {
            padding: 15px 20px; font-size: 18px; border-radius: 30px;
            border: 2px solid rgba(255, 255, 255, 0.3); 
            background: rgba(0,0,0,0.8);
            color: white; outline: none; text-align: center; width: 60%; max-width: 300px;
            margin-bottom: 20px;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.1);
        }
        
        button {
            padding: 12px 50px; font-size: 18px;
            border-radius: 30px; border: none; background: linear-gradient(45deg, #ff4d4d, #ff8c00);
            color: white; cursor: pointer; font-weight: bold;
            box-shadow: 0 0 20px rgba(255, 77, 77, 0.5);
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.95); }

        #disclaimer {
            margin-top: 25px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            width: 80%;
            margin-left: auto;
            margin-right: auto;
            line-height: 1.5;
        }
        
        #hint {
            position: absolute; bottom: 10%; width: 100%;
            text-align: center; color: rgba(255,255,255,0.6); font-size: 14px;
            pointer-events: none; opacity: 0; transition: opacity 1s;
            letter-spacing: 2px;
        }

        #touch-hint {
            position: absolute;
            bottom: 12%; 
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.5);
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s;
            letter-spacing: 1px;
            z-index: 19;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
        }

        /* ============================================================ */
        /* ====== Control Buttons Layer ====== */
        /* ============================================================ */
        #controls-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20;
            opacity: 1; 
            transition: opacity 1.5s;
            pointer-events: none;
        }

        .control-btn {
            pointer-events: auto;
            display: inline-block;
            padding: 8px 16px;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            cursor: pointer;
            backdrop-filter: blur(4px);
            transition: all 0.3s;
            text-decoration: none;
            box-shadow: none; 
            background-image: none; 
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            white-space: nowrap; 
        }
        
        .initially-hidden {
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease-out; 
        }
        
        #btn-auto, #btn-blog, #btn-share {
            position: absolute;
        }

        .reveal-btn {
            opacity: 1 !important;
            pointer-events: auto !important;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .control-btn:active {
            background: rgba(255, 255, 255, 0.4); 
        }

        .control-btn.active {
            background: rgba(255, 165, 0, 0.25); 
            border-color: rgba(255, 190, 80, 0.7);
            color: #fff;
            box-shadow: 0 0 10px rgba(255, 165, 0, 0.2); 
        }

        /* ============================================================ */
        /* ====== åˆ†äº«ç•™è¨€å¼¹çª—æ ·å¼ (Share Modal)  ====== */
        /* ============================================================ */
        #share-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 200;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s;
            backdrop-filter: blur(2px);
        }

        #share-overlay.show {
            opacity: 1; pointer-events: auto;
        }

        .share-box {
            width: 85%; max-width: 400px;
            background: rgba(30, 30, 30, 0.9); /* åŠ æ·±ä¸€ç‚¹èƒŒæ™¯ */
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 20px;
            padding: 25px;
            text-align: center;
            color: #fff;
            position: relative;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            transform: scale(0.95);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #share-overlay.show .share-box {
            transform: scale(1);
        }

        .close-btn {
            position: absolute; top: 15px; right: 20px;
            font-size: 24px; color: rgba(255,255,255,0.5);
            cursor: pointer; font-family: sans-serif;
            transition: color 0.2s;
        }
        .close-btn:hover { color: #fff; }

        .share-title {
            margin: 0 0 15px 0; font-size: 18px; letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.9);
        }

        .share-desc {
            font-size: 13px; color: rgba(255,255,255,0.5); margin-bottom: 15px; line-height: 1.4;
        }

        /* ä¸¤ä¸ªè¾“å…¥æ¡†çš„æ ·å¼ */
        .share-input-group {
            margin-bottom: 10px;
            text-align: left;
        }
        .share-label {
            font-size: 12px; color: rgba(255,255,255,0.6); margin-left: 5px; margin-bottom: 5px; display: block;
        }
        .share-input-area {
            width: 100%; box-sizing: border-box;
            background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px; color: #fff; padding: 10px;
            font-size: 15px; font-family: inherit;
            resize: none; 
            outline: none;
        }
        .share-input-area:focus { border-color: rgba(255,255,255,0.5); }

        .modal-btn {
            padding: 8px 25px; border-radius: 20px; font-size: 14px;
            cursor: pointer; border: none; font-weight: bold; color: white;
            transition: all 0.2s;
            margin-top: 10px;
        }
        .btn-gen { background: linear-gradient(45deg, #ff8c00, #ff4d4d); box-shadow: 0 0 10px rgba(255,77,77,0.3); }
        .modal-btn:active { transform: scale(0.95); }

        .result-container {
            display: none;
            margin-top: 20px; padding-top: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .result-column {
            display: flex; flex-direction: column; gap: 8px; align-items: center;
        }
        .link-output {
            width: 100%; 
            background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px; color: rgba(255,255,255,0.9);
            padding: 10px; font-size: 12px; outline: none;
            word-break: break-all;
            height: auto;
            text-align: left;
        }
        .copy-hint-text {
            font-size: 12px; color: rgba(255,255,255,0.4);
        }

        /* ============================================================ */
        /* ====== Volume Control (Vertical) ====== */
        /* ============================================================ */
        .volume-container {
            position: absolute;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 1; 
            z-index: 25;
        }

        #volume-trigger-btn {
            width: 40px; height: 36px;
            display: flex; justify-content: center; align-items: center;
            font-size: 18px; padding: 0;
        }

        #volume-panel-vertical {
            position: absolute;
            bottom: 50px; left: 50%;
            transform: translateX(-50%) translateY(20px) scale(0.9); 
            width: 140px; height: 140px; 
            background: transparent; 
            display: flex; flex-direction: row; 
            align-items: flex-end; justify-content: center; 
            gap: 20px; padding-bottom: 10px;
            opacity: 0; pointer-events: none;
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 100;
        }

        #volume-panel-vertical.show {
            opacity: 1; transform: translateX(-50%) translateY(0) scale(1);
            pointer-events: auto;
        }

        .vol-slider-wrap {
            height: 100%; display: flex; flex-direction: column;
            align-items: center; justify-content: flex-end; width: 30px;
        }

        .vol-icon-small {
            font-size: 12px; color: rgba(255,255,255,0.8);
            margin-top: 10px; text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }

        .range-holder {
            width: 30px; height: 100px; 
            display: flex; align-items: center; justify-content: center;
        }
        
        input[type=range].vertical-range-transform {
            -webkit-appearance: none; width: 100px; height: 20px;
            background: transparent; transform: rotate(-90deg);
            outline: none; cursor: pointer;
        }

        input[type=range].vertical-range-transform::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: rgba(255, 255, 255, 0.3); border-radius: 1px; border: none;
        }

        input[type=range].vertical-range-transform::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px;
            border-radius: 50%; background: #ffffff;
            margin-top: -6px; box-shadow: 0 0 5px rgba(0,0,0,0.3); border: none;
        }

    </style>
</head>
<body>

    <div id="intro-layer">
        <div id="intro-text" class="breathing"></div>
    </div>

    <div id="ui-layer">
        <input type="text" id="nameInput" placeholder="è¯·è¾“å…¥ä½ çš„åå­—" maxlength="12" oninput="filterInput(this)">
        <br>
        <button onclick="startShow()">å¼€å¯ 2026</button>
        <div id="disclaimer"></div>
    </div>

    <div id="hint">ç‚¹å‡»å±å¹•ç»§ç»­...</div>

    <div id="touch-hint">æˆ³æˆ³å±å¹•æœ‰æƒŠå–œ</div>

    <div id="controls-layer">
        <button class="control-btn initially-hidden" id="btn-auto" onclick="toggleAutoFire()">è‡ªåŠ¨æ”¾çƒŸèŠ±: å…³</button>
        
        <button class="control-btn initially-hidden" id="btn-share" onclick="openShareModal()">æˆ³æˆ‘ç•™è¨€</button>

        <div class="volume-container">
            <div id="volume-panel-vertical">
                <div class="vol-slider-wrap">
                    <div class="range-holder">
                        <input type="range" class="vertical-range-transform" min="0" max="1" step="0.01" value="0.5" id="sfx-slider" oninput="updateSfxVolume(this.value)">
                    </div>
                    <span class="vol-icon-small">ğŸ’¥</span>
                </div>
                <div class="vol-slider-wrap">
                    <div class="range-holder">
                        <input type="range" class="vertical-range-transform" min="0" max="1" step="0.01" value="0.5" id="bgm-slider" oninput="updateBgmVolume(this.value)">
                    </div>
                    <span class="vol-icon-small">ğŸµ</span>
                </div>
            </div>
            <button class="control-btn" id="volume-trigger-btn" onclick="toggleVolumePanel()">ğŸ”Š</button>
        </div>

        <button class="control-btn initially-hidden" id="btn-blog" onclick="goBlog()">è®¿é—®æˆ‘çš„åšå®¢</button>
    </div>

    <div id="share-overlay">
        <div class="share-box">
            <div class="close-btn" onclick="closeShareModal()">Ã—</div>
            <div class="share-title" id="share-title-text"></div>
            <div class="share-desc" id="share-desc-text"></div>
            
            <div class="share-input-group">
                <label class="share-label">å¯¹æ–¹çš„åå­—</label>
                <input type="text" class="share-input-area" id="share-name-input" maxlength="12" placeholder="ä¾‹å¦‚: Maxton" oninput="filterInput(this)">
            </div>
            
            <div class="share-input-group">
                <label class="share-label">æƒ³å¯¹TAè¯´çš„è¯ (éšè—å½©è›‹)</label>
                <textarea class="share-input-area" id="share-msg-input" rows="3" placeholder="åœ¨å¿«é€Ÿæ—‹è½¬åœ†ç¯æ—¶æ‰ä¼šå‡ºç°å“¦..." oninput="filterInput(this)"></textarea>
            </div>
            
            <button class="modal-btn btn-gen" onclick="generateShareLink()">ç”Ÿæˆé“¾æ¥</button>
            
            <div class="result-container" id="share-result">
                <div class="result-column">
                    <textarea class="link-output" id="share-link-output" rows="3" readonly></textarea>
                    <span class="copy-hint-text">è¯·é•¿æŒ‰ä¸Šæ–¹é“¾æ¥æ‰‹åŠ¨å¤åˆ¶</span>
                </div>
            </div>
        </div>
    </div>

    <canvas id="canvas"></canvas>

    <script is:inline>
        // ================= è‡ªå®šä¹‰è°ƒæ•´åŒº =================
        // ======  è¾“å…¥å†…å®¹è¿‡æ»¤å™¨ (ç¦æ­¢è¡¨æƒ…ï¼Œåªå…è®¸ä¸­è‹±æ•°+æ ‡ç‚¹) ======
        function filterInput(input) {
            // æ­£åˆ™è§£é‡Šï¼š
            // ^                 : å–åï¼ˆåŒ¹é…ä¸åœ¨ä»¥ä¸‹èŒƒå›´å†…çš„å­—ç¬¦ï¼‰
            // \u4e00-\u9fa5     : å¸¸ç”¨æ±‰å­—
            // \x20-\x7E         : æ‰€æœ‰ASCIIå­—ç¬¦ (åŒ…å« æ•°å­—ã€å­—æ¯ã€è‹±æ–‡æ ‡ç‚¹ã€ç©ºæ ¼)
            // \u3000-\u303F     : CJK æ ‡ç‚¹ç¬¦å· (å¦‚é¡¿å·ã€å…¨è§’ç©ºæ ¼)
            // \uFF00-\uFFEF     : å…¨è§’ASCIIå˜ä½“ (å¦‚å…¨è§’é€—å·ã€å¥å·ã€æ„Ÿå¹å·)
            // \n                : æ¢è¡Œç¬¦ (å…è®¸ Textarea æ¢è¡Œ)
            const regex = /[^\u4e00-\u9fa5\x20-\x7E\u3000-\u303F\uFF00-\uFFEF\n]/g;
            
            // å¦‚æœå‘ç°äº†éæ³•å­—ç¬¦ï¼Œç›´æ¥æ›¿æ¢ä¸ºç©º
            if (regex.test(input.value)) {
                input.value = input.value.replace(regex, '');
            }
        }
        const CONFIG = {
            
            // ============================================
            // ====== [1. æ ¸å¿ƒä¸URLå‚æ•° (CORE & URL)] ======
            // ============================================
            urlConfig: {
                // æ˜¯å¦å¯ç”¨URLä¼ å‚åŠŸèƒ½
                enabled: true,
                // [åå­—] å‚æ•°åï¼Œä¾‹å¦‚ ?a=...
                paramName: 'n',
                // æ˜¯å¦è‡ªåŠ¨å¡«å…¥è¾“å…¥æ¡† (true=å¡«å…¥, false=ä¸å¡«)
                autoFill: true,
                // å½“é“¾æ¥æŸå/è§£å‹å¤±è´¥æ—¶æ˜¾ç¤ºçš„é”™è¯¯æç¤º (æ”¯æŒHTML)
                errorText: "é“¾æ¥å·²æŸå<br>è¯·è”ç³»TAé‡æ–°è·å–",
                // é”™è¯¯æç¤ºåœç•™æ—¶é—´ (æ¯«ç§’)
                errorDuration: 1300
            },

            // éšè—å½©è›‹ (SECRET MESSAGE) é…ç½®
            secret: {
                // [å¯†è¯­] å‚æ•°åï¼Œä¾‹å¦‚ ?m=... (lz-stringå‹ç¼©)
                paramNameMsg: 'm',
                defaultText: "æƒ³ç»™TAç•™ä¸‹ä»€ä¹ˆè¯å‘¢ï¼Ÿç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ç”Ÿæˆé“¾æ¥... ", // æ²¡æœ‰å‚æ•°æ—¶ï¼Œåœ†ç¯æ˜¾ç¤ºçš„å¼•å¯¼è¯­
                ringErrorText: "é“¾æ¥æ•°æ®ä¸å®Œæ•´ Â· è¯·æ£€æŸ¥é“¾æ¥æˆ–è€…è”ç³»TA Â· ",     // é“¾æ¥å‡ºé”™æ—¶ï¼Œåœ†ç¯æ˜¾ç¤ºçš„é”™è¯¯è¯­
                
                // å›ºå®šåŠå¾„åœ†ç¯é…ç½® (Fixed Ring Logic)
                // è§£é‡Šï¼šä¸ç®¡å­—å¤šå­—å°‘ï¼Œåœ†ç¯éƒ½è¿™ä¹ˆå¤§ï¼Œåƒä¸€ä¸ªä¼ é€å¸¦ä¸€æ ·æ»šåŠ¨å†…å®¹
                ring: {
                    // åœ†ç¯åŠå¾„ (å±å¹•å®½åº¦çš„å€æ•°)
                    radiusMobile: 0.5,  
                    radiusDesktop: 0.2,

                    // æ¯ä¸€åœˆæ˜¾ç¤ºå¤šå°‘ä¸ªå­— (æ§½ä½æ•°é‡)
                    // è¶…è¿‡è¿™ä¸ªæ•°é‡çš„å­—ä¼šå˜æˆâ€œæ— é™å·è½´â€æ•ˆæœ
                    slotsMobile: 20,
                    slotsDesktop: 20
                },

                // ç‰©ç†é˜ˆå€¼é…ç½® (æ ¹æ®æ—‹è½¬é€Ÿåº¦è§¦å‘)
                thresholds: {
                    switch: 0.15,  // è¾¾åˆ°è¿™ä¸ªé€Ÿåº¦è§¦å‘åˆ‡æ¢ (å•ä½: rad/frame)
                    hint: 0.05,    // è¾¾åˆ°è¿™ä¸ªé€Ÿåº¦å¼€å§‹æç¤ºâ€œå†å¿«ç‚¹â€
                    stop: 0.01     // ä½äºè¿™ä¸ªé€Ÿåº¦è§†ä¸ºåœä¸‹ï¼Œæ˜¾ç¤ºæŒ‰é’®
                },

                // æç¤ºè¯­é…ç½®
                hints: {
                    start: "è¯•è¯•å¿«é€Ÿè½¬åŠ¨åœ†ç¯...",
                    faster: "å†å¿«ä¸€ç‚¹ï¼",
                    revealed: "", // æ­æ™“åä¸æ˜¾ç¤ºæç¤ºï¼Œä¿æŒç¥ç§˜
                    // å½“é€Ÿåº¦æå¿«è§¦å‘åˆ‡æ¢åï¼Œç«‹åˆ»æ˜¾ç¤ºçš„æç¤ºè¯­
                    slowDown: "é­”æ³•å‡ºç°ï¼è¯·åœæ­¢è½¬åŠ¨..."
                },

                // ====== éšè—æ–‡å­—å­—ä½“å¤§å° ======
                // è¿™é‡Œç‹¬ç«‹æ§åˆ¶ï¼Œä¸å½±å“å¤–é¢çš„ carouselMobile ç­‰å‚æ•°
                font: {
                    sizeMobile: 55,   // æ‰‹æœºç«¯éšè—æ–‡å­—å¤§å°
                    sizeDesktop: 120  // ç”µè„‘ç«¯éšè—æ–‡å­—å¤§å°
                },
                
                // è¿œæ™¯æ·¡å‡ºå¼ºåº¦
                // æ•°å€¼è¶Šå¤§ï¼Œåœ†ç¯èƒŒé¢æ¶ˆå¤±å¾—è¶Šå¿«ï¼Œé˜²æ­¢ç©¿å¸®
                fadePower: 2.5
            },

            // ============================================
            // ====== [2. å­—ä½“ä¸ä¸ªæ€§åŒ– (FONT)] ======
            // ============================================
            font: {
                // æ˜¯å¦å¯ç”¨è‡ªå®šä¹‰å­—ä½“ï¼Ÿ(false åˆ™ä½¿ç”¨é»˜è®¤å¾®è½¯é›…é»‘)
                enabled: true, 
                // å­—ä½“æ–‡ä»¶çš„ URL åœ°å€ (æ”¯æŒ woff2, ttf, otf)
                url: '/fonts/ZhanKuXiaoLOGOTi-2.otf', 
                // å­—ä½“åç§° (éœ€åœ¨ CSS æˆ– JS ä¸­å¼•ç”¨çš„åå­—)
                family: 'MyCustomFont'
            },

            // ============================================
            // ====== [3. äº¤äº’ä¸ç‰©ç† (INTERACTION)] ======
            // ============================================
            interaction: {
                // --- åº•éƒ¨ 3D åœ†ç¯çš„æƒ¯æ€§æ‹–æ‹½å‚æ•° ---
                inertia: {
                    // æ‹–æ‹½çµæ•åº¦ (æ•°å€¼è¶Šå¤§ï¼Œæ‰‹æŒ‡åŠ¨ä¸€ç‚¹ç‚¹åœ†ç¯è½¬å¾—è¶Šå¿«)
                    dragSensitivity: 0.003,
                    
                    // æƒ¯æ€§æ‘©æ“¦åŠ› (0.0 ~ 1.0)
                    // æ•°å€¼è¶Šå°ï¼Œæ¾æ‰‹ååœ†ç¯åœå¾—è¶Šå¿«ï¼›æ•°å€¼è¶Šå¤§ï¼Œæƒ¯æ€§æ»‘è¡Œè¶Šä¹…
                    friction: 0.99,
                    
                    // è‡ªåŠ¨æ¢å¤åŠ› (0.0 ~ 1.0)
                    // æ¾æ‰‹åï¼Œåœ†ç¯é€Ÿåº¦æ…¢æ…¢å›å½’åˆ°é»˜è®¤ rotationSpeed çš„é€Ÿåº¦
                    // æ•°å€¼è¶Šå°ï¼Œæ¢å¤å¾—è¶Šæ…¢ï¼ˆæ›´ä¸æ»‘ï¼‰ï¼›æ•°å€¼è¶Šå¤§ï¼Œæ¢å¤å¾—è¶Šå¿«
                    restoreSpeed: 0.01
                }
            },

            // ============================================
            // ====== [4. æ–‡å­—å†…å®¹é…ç½® (TEXT CONTENT)] ======
            // ============================================
            
            // å¦‚æœä¸‹é¢çš„ textLogic.randomize ä¸º falseï¼Œåˆ™ä½¿ç”¨è¿™äº›å›ºå®šçš„è¯
            transitionTexts: ["å‰ç¨‹ä¼¼é”¦", "å­¦ä¸šæœ‰æˆ","å¹³å®‰å–œä¹"],
            carouselTexts: ["è´¢æºå¹¿è¿›", "å‰æ˜Ÿé«˜ç…§", "å¿ƒæƒ³äº‹æˆ", "ä¸€å¸†é£é¡º", "æœªæ¥å¯æœŸ"],

            // è¯æ±‡åº“é€»è¾‘æ§åˆ¶
            textLogic: {
                // æ˜¯å¦å¼€å¯éšæœºæŠ½å–ï¼Ÿ 
                // true = æ¯æ¬¡åˆ·æ–°ç½‘é¡µéƒ½ä» pool é‡Œéšæœºé€‰è¯è¦†ç›–ä¸Šé¢çš„æ•°ç»„
                // false = ä½¿ç”¨ä¸Šé¢å›ºå®šçš„ transitionTexts å’Œ carouselTexts
                randomize: true, 

                // éšæœºæŠ½å–æ•°é‡é…ç½®
                transitionCount: 3, // ä¸Šé¢éšæœºé€‰3ä¸ª
                carouselCount: 5,   // ä¸‹é¢éšæœºé€‰5ä¸ª

                // å¤§è¯åº“ (Pool) - ä½ å¯ä»¥æ— é™å¾€è¿™é‡ŒåŠ è¯
                pool: [
                    "å‰ç¨‹ä¼¼é”¦", "å­¦ä¸šæœ‰æˆ", "å¹³å®‰å–œä¹", "è´¢æºå¹¿è¿›", "å‰æ˜Ÿé«˜ç…§", 
                    "å¿ƒæƒ³äº‹æˆ", "ä¸€å¸†é£é¡º", "æœªæ¥å¯æœŸ", "ä¸‡äº‹å¦‚æ„", "èº«ä½“å¥åº·",
                    "æ­¥æ­¥é«˜å‡", "é˜–å®¶å¹¸ç¦", "å¤§å±•å®å›¾", "é‡‘æ¦œé¢˜å", "å¥½è¿è¿è¿",
                    "ç¬‘å£å¸¸å¼€", "æ—¥è¿›æ–—é‡‘", "é£é»„è…¾è¾¾", "è¯¸äº‹é¡ºé‚", "ç¦æ˜Ÿé«˜ç…§",
                    "å²å²å¹³å®‰", "å¹´å¹´æœ‰ä½™", "äº‹ä¸šæœ‰æˆ", "æ¢¦æƒ³æˆçœŸ"
                ]
            },

            textColors: {
                initialMode: 'gold', // 'gold', 'red', 'rainbow', 'white'
                randomize: false      // æ˜¯å¦éšæœºå˜è‰²
            },

            // ============================================
            // ====== [5. å­—ä½“ä¸æ’ç‰ˆ (FONTS & LAYOUT)] ======
            // ============================================
            fontSizes: {
                // [å¼€åœºæ–‡å­—] (è¾“å…¥åå­—åçš„é‚£ä¸ªå¤§å­—)
                introMobile: 85,    // æ‰‹æœºç«¯å¤§å° (å¤ªå¤§å¯èƒ½ä¼šè¶…å‡ºå±å¹•)
                introDesktop:200,   // ç”µè„‘ç«¯å¤§å°

                // [æœ€ç»ˆé¡µé¢] ä¸ŠåŠéƒ¨åˆ†çš„é™æ€å­—
                finalTitleMobile: 55,   // "ç¥"
                finalTitleDesktop: 80,
                
                finalNameMobile: 90,    // ä½ çš„åå­—
                finalNameDesktop: 130,
                
                finalYearMobile: 70,    // "2026"
                finalYearDesktop: 100,
                
                // [æœ€ç»ˆé¡µé¢] åº•éƒ¨æ—‹è½¬åœ†ç¯çš„å­—
                carouselMobile: 55, 
                carouselDesktop: 100
            },

            // --- 3D å¸ƒå±€å‚æ•° ---
            // [ä¸­å¿ƒé«˜åº¦] 0=é¡¶éƒ¨, 0.5=å±å¹•æ­£ä¸­é—´, 1=åº•éƒ¨
            centerYMobile: 0.53,    
            centerYDesktop: 0.5,    
            
            // [åœ†ç¯åŠå¾„] å±å¹•å®½åº¦çš„å€æ•°ã€‚å¤ªå¤§å­—ä¼šå‡ºå±å¹•ï¼Œå¤ªå°å­—æŒ¤åœ¨ä¸€èµ·ã€‚
            carouselRadiusRatioMobile: 0.45, 
            carouselRadiusRatioDesktop: 0.2, 

            // [ä¿¯è§†è§’åº¦] 0=å¹³è§†(ä¸€æ¡çº¿), 1=å®Œå…¨ä¿¯è§†(æ­£åœ†)
            tiltFactorMobile: 0.5,    
            tiltFactorDesktop: 0.4,    
            
            // [é€è§†æ„Ÿ] æ•°å€¼è¶Šå°ï¼Œè¿‘å¤§è¿œå°çš„æ•ˆæœè¶Šå¤¸å¼ ã€‚
            fovMobile: 1000,    
            fovDesktop: 1400,

            // ============================================
            // ====== [6. ç²’å­ç³»ç»Ÿè®¾ç½® (PARTICLES)] ======
            // ============================================
            // æ•°å€¼ä»£è¡¨â€œæ¯éš”å¤šå°‘ä¸ªåƒç´ å–ä¸€ä¸ªç‚¹â€ã€‚
            // 1 = æœ€å¯† (100% è¿˜åŸ), 1.5 = é€‚ä¸­, 2 = ç¨€ç–
            density: {
                // å¼€åœºé˜¶æ®µ
                introMobile: 1.2,    // â˜… å»ºè®®è®¾ç½® 1.3 ~ 1.6 ä¹‹é—´
                introDesktop: 2,
                
                // æœ€ç»ˆé˜¶æ®µ (å› ä¸ºå­—å¤šï¼Œå»ºè®®æ¯”ä¸Šé¢ç¨å¾®å¤§ä¸€ç‚¹ç‚¹ï¼Œé˜²æ­¢å¤ªä¹±)
                finalMobile: 1.6,    // â˜… å»ºè®®è®¾ç½® 2.0 ~ 2.5
                finalDesktop: 3
            },

            // --- è§†è§‰ä¸å‘å…‰æ§åˆ¶ ---
            visuals: {
                // [å…¨å±€å‘å…‰] true: å¼€å¯æš´åŠ›å åŠ æ¨¡å¼ï¼Œæ‰€æœ‰ç²’å­éƒ½å‘å…‰ã€‚
                globalAdditive: false, 

                // [å‘¼å¸é«˜äº®] true: åªæœ‰â€œæ­£åœ¨é—ªçƒâ€çš„ç²’å­æ‰å¼€å¯é«˜äº®å åŠ ã€‚
                twinkleAdditive: true,

                // [åŸºç¡€äº®åº¦] èŒƒå›´ 0.1(æš—) ~ 1.0(äº®)ã€‚
                alphaFactor: 0.8
            },

            // --- ç²’å­å‘¼å¸/é—ªçƒå‚æ•° ---
            twinkle: {
                enabled: true,       // æ€»å¼€å…³
                probability: 0.9,    // é—ªçƒå¯†åº¦ (0.7 = 70% çš„ç²’å­ä¼šå‚ä¸é—ªçƒ)
                minOpacity: 0.1,     // [æ˜æš—å¯¹æ¯”åº¦] é—ªçƒæ—¶æœ€æš—èƒ½åˆ°å¤šå°‘
                maxOpacity: 1.0,     // é—ªçƒæ—¶æœ€äº®èƒ½åˆ°å¤šå°‘
                speedMin: 0.03,      // é—ªçƒé€Ÿåº¦ä¸‹é™
                speedMax: 0.06,      // é—ªçƒé€Ÿåº¦ä¸Šé™
                
                // [é”åŒ–ç³»æ•°] 1 = å¹³æ»‘, 3 = å°–é” (åƒæ˜Ÿæ˜Ÿ)
                sharpness: 2.5  
            },

            // ============================================
            // ====== [7. åŠ¨ç”»ä¸ç‰©ç† (ANIMATION)] ======
            // ============================================
            rotationSpeed: 0.004, // åº•éƒ¨åœ†ç¯æ—‹è½¬é€Ÿåº¦ (é»˜è®¤è‡ªè½¬é€Ÿåº¦)
            particleEase: 0.05,    // ç²’å­é£è¡Œçš„åˆ¹è½¦åŠ›åº¦ (0.01=è¶…æ…¢, 0.1=è¶…å¿«)

            // ============================================
            // ====== [8. èƒŒæ™¯ä¸æ°›å›´ (BACKGROUND)] ======
            // ============================================
            background: {
                enabled: true,       // æ˜¯å¦å¼€å¯èƒŒæ™¯æ¼‚æµ®ç‰©
                
                // æ ·å¼é€‰æ‹©: 'mix'(æ··åˆæ¨è), 'circle'(åœ†), 'cross'(åå­—), 'ring'(ç©ºå¿ƒåœˆ)
                style: 'mix',

                // èƒŒæ™¯ç²’å­æ•°é‡
                countMobile: 40,      
                countDesktop: 80,

                // æ¼‚æµ®é€Ÿåº¦ (è¶Šå°è¶Šæ…¢ï¼Œè¥é€ å¤ªç©ºæ„Ÿ)
                speed: 0.3,            

                // ç²’å­å¤§å°èŒƒå›´
                sizeMin: 2.0,
                sizeMax: 8.0,

                // é¢œè‰²ä¸é€æ˜åº¦
                color: '255, 255, 255', // RGB é¢œè‰²
                opacity: 0.4            // åŸºç¡€é€æ˜åº¦
            },

            // ============================================
            // ====== [9. çƒŸèŠ±ç³»ç»Ÿé…ç½® (FIREWORKS)] ======
            // ============================================
            fireworks: {
                // ä¸Šå‡é€Ÿåº¦ (æ•°å€¼è¶Šå¤§è¶Šå¿«)
                launchSpeedMobile: 3,
                launchSpeedDesktop: 4,

                // ä¸Šå‡æ—¶çš„æŠ–åŠ¨å¹…åº¦ (æ¨¡æ‹Ÿé£è¡Œä¸ç¨³)
                ascentWobble: 3, 

                // çˆ†ç‚¸åç²’å­æ•°é‡
                explosionCountMobile: 60,
                explosionCountDesktop: 120,

                // çˆ†ç‚¸åŠ›åº¦ (Spread)
                explosionForce: 6,
                
                // é‡åŠ› (çƒŸèŠ±ä¸‹å çš„æ„Ÿè§‰)
                gravity: 0.05,
                
                // é˜»åŠ› (ç©ºæ°”é˜»åŠ›ï¼Œé˜²æ­¢é£å¤ªè¿œ)
                friction: 0.96,

                // ç²’å­æ®‹ç•™æ—¶é—´æ§åˆ¶ (æ•°å€¼è¶Šå°ï¼Œæ¶ˆå¤±è¶Šæ…¢)
                decayMin: 0.003,
                decayMax: 0.008,

                // --- çˆ†ç‚¸èŠ±æ · ---
                patterns: {
                    // çˆ†ç‚¸å½¢çŠ¶æ§åˆ¶ï¼šæ˜¯å¦å¯ç”¨å¤šç§èŠ±æ ·
                    enabled: true, 

                    // çˆ†ç‚¸èŒƒå›´ç¼©æ”¾ (Scale)
                    scaleMobile: 1.2,
                    scaleDesktop: 1.5 
                },

                // --- æ–‡å­—çƒŸèŠ± (æ ¸å¿ƒåŠŸèƒ½) ---
                textFireworks: {
                    enabled: true,
                    
                    // å‡ºç°çš„æ¦‚ç‡ (0.3 è¡¨ç¤º 30% çš„çƒŸèŠ±ä¼šç‚¸æˆæ–‡å­—)
                    probability: 0.3, 

                    // ç¥ç¦è¯­åˆ—è¡¨ (ç‚¸å¼€æ—¶éšæœºé€‰ä¸€ä¸ª)
                    words: ["ç¦", "ä¹", "é¡º", "å‘", "å‰", "å®‰"],
                    
                    // æ–‡å­—ç²’å­çš„å¤§å°
                    particleSizeMobile: 1.8,
                    particleSizeDesktop: 2.5,

                    // æ–‡å­—ç‚¸å¼€çš„èŒƒå›´å¤§å°
                    explosionScaleMobile: 1.5,
                    explosionScaleDesktop: 2.2,

                    // æ–‡å­—çƒŸèŠ±çš„æŒç»­æ—¶é—´
                    decaySpeed: 0.004,

                    // é¢œè‰²æ§åˆ¶æ¨¡å¼: 'gold', 'random', 'fixed'
                    colorMode: 'random', 
                    
                    // å½“ colorMode ä¸º 'fixed' æ—¶ç”Ÿæ•ˆ
                    fixedColor: '255, 255, 255'
                },

                // --- å°¾çƒŸé…ç½® ---
                smoke: {
                    enabled: true,
                    color: '180, 180, 180',
                    sizeMobile: 1.5,
                    sizeDesktop: 2.5,
                    decaySpeed: 0.02,
                    interval: 2,
                    jitter: 0.5
                }
            },

            // ============================================
            // ====== [10. UI ä¸äº¤äº’ (UI)] ======
            // ============================================
            ui: {
                // åšå®¢è·³è½¬é“¾æ¥
                blogUrl: "https://zh.maxtonniu.com",

                // åº•éƒ¨é˜²è¯¯è§¦åŒºåŸŸé«˜åº¦ (px)
                safeZoneHeightMobile: 100,
                safeZoneHeightDesktop: 80,

                // æç¤ºè¯­æ–‡å­—
                touchHintText: "æˆ³æˆ³å±å¹•æœ‰æƒŠå–œ",

                // å…è´£å£°æ˜å†…å®¹é…ç½®
                disclaimer: {
                    text: "æœ¬ç½‘é¡µåŸºäºçº¯é™æ€å‰ç«¯ï¼Œä¸ä¼šæ”¶é›†æ‚¨ä»»ä½•è¾“å…¥çš„ä¸œè¥¿ï¼ˆæˆ‘å“ªæœ‰è¿™é—²é’±ä¹°æœåŠ¡å™¨è¿™ä¸œè¥¿ï¼‰",
                    color: "rgba(255, 255, 255, 0.4)",
                    fontSize: "12px"
                },

                // è‡ªåŠ¨æ”¾çƒŸèŠ±çš„å‚æ•°
                autoFire: {
                    minInterval: 300,  // æœ€å¿«å¤šä¹…æ”¾ä¸€æ¬¡ (æ¯«ç§’)
                    maxInterval: 1200, // æœ€æ…¢å¤šä¹…æ”¾ä¸€æ¬¡ (æ¯«ç§’)
                    maxConcurrent: 3   // æ¯æ¬¡å¹¶å‘æœ€å¤šæ”¾å‡ ä¸ª?
                },

                // ====== ç•™è¨€åˆ†äº«åŠŸèƒ½ (SHARE) ======
                share: {
                    // è‡ªå®šä¹‰ç”Ÿæˆé“¾æ¥çš„åŸºç¡€åŸŸå (ä¸è¾“å…¥æ—¶é»˜è®¤ç”Ÿæˆçš„åŸŸå)
                    baseUrl: "http://zh.maxtonniu.com/newyear", 
                    
                    // å¿…é¡»ä¸ä¸Šæ–¹ urlConfig.paramName ä¿æŒä¸€è‡´ï¼Œè¿™é‡Œæ˜¯è‡ªåŠ¨è·Ÿéšçš„
                    get paramName() { return CONFIG.urlConfig.paramName; },
                    
                    // å¼¹çª—æ ‡é¢˜
                    modalTitle: "å®šåˆ¶ä½ çš„ç¥ç¦é“¾æ¥",
                    
                    // æç¤ºè¯´æ˜æ–‡å­—
                    modalDesc: "ç”Ÿæˆä¸“å±é“¾æ¥å‘ç»™Taã€‚<br>å¦‚æœå¡«å†™äº†â€œéšè—å½©è›‹â€ï¼Œå‘Šè¯‰Taï¼š<br><b>å¿«é€Ÿè½¬åŠ¨åœ†ç¯ï¼Œä¼šæœ‰æƒŠå–œå“¦ï¼</b>",
                    
                    // æŒ‰é’®æ–‡å­—
                    btnText: "æˆ³æˆ‘ç•™è¨€"
                },

                // ====== æŒ‰é’®ä½ç½®è‡ªå®šä¹‰é…ç½® (BUTTON POSITIONS) ======
                positions: {
                    // --- 1. è‡ªåŠ¨çƒŸèŠ±æŒ‰é’® (Auto Fire Button) ---
                    autoBtn: {
                        mobile: {
                            bottom: '4%',      // è·ç¦»åº•éƒ¨
                            left: '8%',        // è·ç¦»å·¦ä¾§
                            top: null, right: null // ä¸ç”¨ç®¡
                        },
                        desktop: {
                            bottom: '4%',
                            left: '8%',
                            top: null, right: null
                        }
                    },

                    // --- 2. è¿”å›åšå®¢æŒ‰é’® (Back Blog Button) ---
                    blogBtn: {
                        mobile: {
                            bottom: '4%',
                            right: '10%',        // è·ç¦»å³ä¾§
                            top: null, left: null
                        },
                        desktop: {
                            bottom: '4%',
                            right: '10%',
                            top: null, left: null
                        }
                    },

                    // --- 3. éŸ³é‡æ§åˆ¶æŒ‰é’® (Volume Button) ---
                    volumeBtn: {
                        mobile: {
                            bottom: '4%',
                            left: '50%',        // å±…ä¸­
                            top: null, right: null
                        },
                        desktop: {
                            bottom: '4%',
                            left: '50%',
                            top: null, right: null
                        }
                    },
                    
                    // --- 4. åˆ†äº«ç•™è¨€æŒ‰é’® (Share Button) ---
                    // é»˜è®¤æ”¾ç½®åœ¨éŸ³é‡æŒ‰é’®çš„ä¸Šæ–¹ (Bottom 15% å·¦å³)
                    shareBtn: {
                        mobile: {
                            bottom: '10%',      // æ¯”éŸ³é‡æŒ‰é’®(4%)é«˜
                            left: '50%',        // å±…ä¸­
                            top: null, right: null
                        },
                        desktop: {
                            bottom: '10%',
                            left: '50%',
                            top: null, right: null
                        }
                    }
                }
            },

            // ============================================
            // ====== [11. éŸ³é¢‘ä¸éŸ³ä¹ (AUDIO)] ======
            // ============================================
            sound: {
                enabled: false,       // çƒŸèŠ±éŸ³æ•ˆæ€»å¼€å…³ (å»ºè®®ç”±æ»‘å—æ§åˆ¶)
                volume: 0.5,         // çƒŸèŠ±éŸ³æ•ˆå…¨å±€åˆå§‹éŸ³é‡ (0 ~ 1)
                
                // èµ„æºè·¯å¾„å®šä¹‰
                files: {
                    lift: ['/audio/lift1.mp3', '/audio/lift2.mp3', '/audio/lift3.mp3'],
                    burst: ['/audio/burst1.mp3', '/audio/burst2.mp3'],
                    burstSmall: ['/audio/burst-sm-1.mp3', '/audio/burst-sm-2.mp3'],
                    crackle: ['/audio/crackle1.mp3', '/audio/crackle-sm-1.mp3']
                }
            },

            // èƒŒæ™¯éŸ³ä¹é…ç½® (BGM)
            music: {
                enabled: true,       // èƒŒæ™¯éŸ³ä¹æ€»å¼€å…³
                volume: 0.5,         // èƒŒæ™¯éŸ³ä¹åˆå§‹éŸ³é‡ (0 ~ 1)
                
                // éŸ³ä¹æ–‡ä»¶åˆ—è¡¨ (è¯·æ”¾åœ¨ public/audio/bgm/ ç›®å½•ä¸‹)
                // åˆ·æ–°é¡µé¢æ—¶ä¼šéšæœºä»è¿™é‡Œé€‰ä¸€é¦–ä½œä¸ºæœ¬æ¬¡çš„ BGM
                files: [
                    '/audio/bgm/daoxiang.mp3',
                    '/audio/bgm/xiyuanqian.mp3',
                    '/audio/bgm/longjuanfeng.mp3'
                ]
            },

            // ============================================
            // ====== [12. å¼€åœºåŠ¨ç”»é…ç½® (INTRO)] ======
            // ============================================
            intro: {
                // æ˜¯å¦å¯ç”¨å¼€åœºåŠ¨ç”»
                enabled: true, 

                // true = æ— è®ºå¤šå°‘æ¬¡è®¿é—®éƒ½æ˜¾ç¤º; false = ç¬¬ä¸€æ¬¡è®¿é—®æ˜¾ç¤ºï¼Œä¹‹ååˆ·æ–°ä¸æ˜¾ç¤º
                alwaysShow:false, 

                // å¼€åœºæ˜¾ç¤ºçš„æ–‡å­—åºåˆ— (å¯è‡ªå®šä¹‰)
                texts: ["å»ºè®®å¼€å¯å£°éŸ³<br>è·å¾—æœ€ä½³ä½“éªŒ", "Maxton ä½œå“"],
                
                // æ¯ä¸ªæ–‡å­—æ˜¾ç¤ºçš„åœç•™æ—¶é—´ (æ¯«ç§’)
                duration: 2000, 
                
                // æ·¡å…¥æ·¡å‡ºçš„è¿‡æ¸¡æ—¶é—´ (æ¯«ç§’)
                fadeSpeed: 1000
            }
        };
        // ===============================================

        // åˆå§‹åŒ–è¯æ±‡é€»è¾‘ï¼šå¦‚æœå¼€å¯éšæœºï¼Œåˆ™è¦†ç›–åŸæœ‰çš„ transitionTexts å’Œ carouselTexts
        function initTextLogic() {
            if (CONFIG.textLogic.randomize && CONFIG.textLogic.pool.length > 0) {
                // 1. å…‹éš†å¹¶æ‰“ä¹±å¤§è¯åº“
                const shuffled = [...CONFIG.textLogic.pool].sort(() => Math.random() - 0.5);
                
                // 2. æˆªå–éœ€è¦çš„æ•°é‡
                const tCount = CONFIG.textLogic.transitionCount;
                const cCount = CONFIG.textLogic.carouselCount;
                
                // é˜²æ­¢æ•°ç»„è¶Šç•Œ
                if (shuffled.length >= tCount + cCount) {
                    CONFIG.transitionTexts = shuffled.slice(0, tCount);
                    CONFIG.carouselTexts = shuffled.slice(tCount, tCount + cCount);
                } else {
                    console.warn("è¯æ±‡åº“æ•°é‡ä¸è¶³ï¼Œæ— æ³•å®Œå…¨éšæœºï¼Œå›é€€åˆ°é»˜è®¤è®¾ç½®");
                }
            }
        }
        // ç«‹å³æ‰§è¡Œè¯æ±‡åˆå§‹åŒ–
        initTextLogic();

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d'); 
        
        // åº”ç”¨ UI é…ç½®ä½ç½® (è¿™é‡Œç¨ååœ¨ resize ä¸­è°ƒç”¨)
        document.getElementById('touch-hint').innerText = CONFIG.ui.touchHintText;
        
        // åº”ç”¨åˆ†äº«æ¨¡å—çš„æ–‡æœ¬é…ç½®
        document.getElementById('btn-share').innerText = CONFIG.ui.share.btnText;
        document.getElementById('share-title-text').innerText = CONFIG.ui.share.modalTitle;
        document.getElementById('share-desc-text').innerHTML = CONFIG.ui.share.modalDesc; // æ”¯æŒHTMLæ¢è¡Œ
        // å ä½ç¬¦ä¸å†å…¨å±€ç»Ÿä¸€ï¼Œè€Œæ˜¯åˆ†å¼€é…ç½®
        // document.getElementById('share-input').placeholder = CONFIG.ui.share.placeholder; 

        // åº”ç”¨æŒ‰é’®è‡ªå®šä¹‰ä½ç½®é€»è¾‘ (Apply Custom Button Positions)
        function applyButtonPositions() {
            const posCfg = CONFIG.ui.positions;
            const mode = isMobile ? 'mobile' : 'desktop';

            // è¾…åŠ©å‡½æ•°ï¼šåº”ç”¨æ ·å¼åˆ°å…ƒç´ 
            function setStyle(elemId, cfg) {
                const el = document.getElementById(elemId);
                if (!el) return;

                // é‡ç½®æ‰€æœ‰å®šä½
                el.style.top = 'auto';
                el.style.bottom = 'auto';
                el.style.left = 'auto';
                el.style.right = 'auto';
                el.style.transform = 'none'; // é‡ç½® transform
                el.style.margin = '0';       // é‡ç½® margin

                // åº”ç”¨æ–°é…ç½®
                if (cfg.top) el.style.top = cfg.top;
                if (cfg.bottom) el.style.bottom = cfg.bottom;
                if (cfg.left) el.style.left = cfg.left;
                if (cfg.right) el.style.right = cfg.right;

                // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœ left æ˜¯ 50%ï¼Œè‡ªåŠ¨åŠ å±…ä¸­åç§»
                if (cfg.left === '50%') {
                    el.style.transform = 'translateX(-50%)';
                }
            }

            // 1. è‡ªåŠ¨çƒŸèŠ±æŒ‰é’®
            setStyle('btn-auto', posCfg.autoBtn[mode]);
            
            // 2. è¿”å›åšå®¢æŒ‰é’®
            setStyle('btn-blog', posCfg.blogBtn[mode]);
            
            // 3. åˆ†äº«æŒ‰é’®
            setStyle('btn-share', posCfg.shareBtn[mode]);

            // 4. éŸ³é‡å®¹å™¨ (æ³¨æ„ï¼šæˆ‘ä»¬å®šä½çš„æ˜¯ .volume-container ç±»)
            // å› ä¸º volume-container æ˜¯ classï¼Œè¿™é‡Œæ‰‹åŠ¨è·å–
            const volContainer = document.querySelector('.volume-container');
            if (volContainer) {
                const vCfg = posCfg.volumeBtn[mode];
                volContainer.style.top = 'auto'; volContainer.style.bottom = 'auto';
                volContainer.style.left = 'auto'; volContainer.style.right = 'auto';
                volContainer.style.transform = 'none';

                if (vCfg.top) volContainer.style.top = vCfg.top;
                if (vCfg.bottom) volContainer.style.bottom = vCfg.bottom;
                if (vCfg.left) volContainer.style.left = vCfg.left;
                if (vCfg.right) volContainer.style.right = vCfg.right;

                if (vCfg.left === '50%') {
                    volContainer.style.transform = 'translateX(-50%)';
                }
            }
        }

        // åº”ç”¨å…è´£å£°æ˜å†…å®¹
        const disclaimerEl = document.getElementById('disclaimer');
        disclaimerEl.innerText = CONFIG.ui.disclaimer.text;
        disclaimerEl.style.color = CONFIG.ui.disclaimer.color;
        disclaimerEl.style.fontSize = CONFIG.ui.disclaimer.fontSize;

        let width, height, dpr;
        let particles = []; 
        let staticTopParticles = []; 
        
        //  æ¸²æŸ“é˜Ÿåˆ—åˆ†ç¦»ï¼šæ­£å¸¸æ¨¡å¼å’Œéšè—æ¨¡å¼
        let carouselGroups = [];       // é»˜è®¤æ˜¾ç¤ºçš„è¯
        
        let charParticleCache = {};    // ç¼“å­˜å­—ç¬¦çš„ç‚¹é˜µæ•°æ® {'A': [particles...]}
        let normalizedSecretText = ""; // å¤„ç†åé¦–å°¾ç›¸æ¥çš„æ— é™é•¿æ–‡æœ¬
        let secretSlotCount = 0;       // éšè—æ¨¡å¼ä¸‹çš„æ§½ä½æ•°é‡
        
        let renderQueue = [];
        
        // èƒŒæ™¯ç²’å­æ•°ç»„
        let bgParticles = [];
        
        // çƒŸèŠ±ç›¸å…³æ•°ç»„
        let fireworks = []; // æ­£åœ¨ä¸Šå‡çš„ç«ç®­
        let sparks = [];    // çˆ†ç‚¸åçš„ç«èŠ±
        // å°¾çƒŸæ•°ç»„
        let smokeParticles = [];

        let isMobile = false;
        let baseParticleSize = 1.8; 
        let step = 0;
        let userName = "";
        let secretMessageText = null; // å­˜å‚¨è§£å‹åçš„éšè—æ–‡å­—
        let isFinalState = false; 
        let globalRotation = 0;

        // æ¸²æŸ“çŠ¶æ€æ§åˆ¶ (NORMAL -> REVEALING -> SECRET)
        let renderState = 'NORMAL'; 

        // æƒ¯æ€§æ‹–æ‹½ç›¸å…³çŠ¶æ€å˜é‡
        const dragState = {
            isDragging: false,
            startX: 0,
            lastX: 0,
            velocity: 0 // å½“å‰é¢å¤–çš„æ‹–æ‹½é€Ÿåº¦ï¼ˆä¸åŒ…å«åŸºç¡€è‡ªè½¬ï¼‰
        };
        
        //  ç”¨äºé€Ÿåº¦è¡¥å¿çš„å˜é‡
        let normalRingRadius = 0;
        let secretRingRadius = 0;
        let hasSwitchedRadius = false; // æ ‡è®°æ˜¯å¦æ‰§è¡Œè¿‡é€Ÿåº¦è¡¥å¿

        // è‡ªåŠ¨çƒŸèŠ±ç›¸å…³
        let autoFireTimer = null;
        let isAutoFiring = false;
        
        // æç¤ºè¯­çŠ¶æ€
        let hasTouchedInFinal = false;

        // ===============================================
        // ====== [é€»è¾‘] å¼€åœºåŠ¨ç”»ç®¡ç† ======
        // ===============================================
        
        // è¾…åŠ©å‡½æ•°ï¼šæ˜¾ç¤ºè¾“å…¥æ¡† UI å±‚
        function showUILayer() {
            const introLayer = document.getElementById('intro-layer');
            const uiLayer = document.getElementById('ui-layer');
            
            // æ·¡å‡ºå¼€åœºå±‚
            introLayer.style.opacity = 0;
            setTimeout(() => {
                introLayer.style.display = 'none'; // å½»åº•éšè—
                uiLayer.style.display = 'block';   // æ˜¾ç¤ºè¾“å…¥æ¡†å±‚
                setTimeout(() => { uiLayer.style.opacity = 1; }, 50); // UI æ·¡å…¥
            }, CONFIG.intro.fadeSpeed);
        }

        // URL å‚æ•°æ£€æŸ¥ä¸é€»è¾‘å¤„ç† - åŒé‡æ£€æµ‹ + åŒé‡æŠ¥é”™ + é”™è¯¯ä¸å¡«å…¥
        function checkUrlAndProceed() {
            // 1. å¦‚æœæ²¡å¼€å¯åŠŸèƒ½ï¼Œç›´æ¥æ˜¾ç¤ºé»˜è®¤å¼•å¯¼è¯­å¹¶è¿›å…¥
            if (!CONFIG.urlConfig.enabled) {
                secretMessageText = CONFIG.secret.defaultText;
                showUILayer();
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            // è·å–åŸå§‹å‚æ•°å­—ç¬¦ä¸²
            const rawNameVal = urlParams.get(CONFIG.urlConfig.paramName);  // n
            const rawMsgVal = urlParams.get(CONFIG.secret.paramNameMsg);   // m

            // 2. å°è¯•è§£å‹åå­—
            let decodedName = null;
            if (rawNameVal) {
                try {
                    decodedName = LZString.decompressFromEncodedURIComponent(rawNameVal);
                } catch (e) { console.error("Name decompress error", e); }
            }

            // 3. å°è¯•è§£å‹å¯†è¯­
            let decodedMsg = null;
            if (rawMsgVal) {
                try {
                    decodedMsg = LZString.decompressFromEncodedURIComponent(rawMsgVal);
                } catch (e) { console.error("Msg decompress error", e); }
            }

            // ====== æ ¸å¿ƒåˆ¤æ–­é€»è¾‘ ======
            
            // å®šä¹‰åé“¾æ¥ï¼š(æœ‰å‚æ•°n ä½†è§£å‹å¤±è´¥) æˆ–è€… (æœ‰å‚æ•°m ä½†è§£å‹å¤±è´¥)
            const isNameBad = (rawNameVal && !decodedName);
            const isMsgBad = (rawMsgVal && !decodedMsg);

            // ã€åˆ†æ”¯ä¸€ï¼šåªè¦æœ‰ä¸€ä¸ªåäº† (nåäº† æˆ– måäº†)ï¼Œç»Ÿç»ŸæŠ¥é”™ã€‘
            if (isNameBad || isMsgBad) {
                
                // A. è®¾ç½®åœ†ç¯æ–‡å­—ä¸ºâ€œé”™è¯¯æç¤ºâ€ (æ»¡è¶³ï¼šåœ†ç¯æç¤ºé“¾æ¥æŸå)
                secretMessageText = CONFIG.secret.ringErrorText;

                // B. ã€æ»¡è¶³ï¼šnå‡ºé”™ä¸å¡«å…¥ã€‘
                // è¿™é‡Œæ²¡æœ‰ä»»ä½•ç»™ nameInput èµ‹å€¼çš„ä»£ç ï¼Œæ‰€ä»¥è¾“å…¥æ¡†ä¿æŒç©ºç™½ã€‚
                // å³ä½¿ n æ˜¯å¥½çš„ä½† m åäº†ï¼Œä¸ºäº†å®‰å…¨èµ·è§ï¼Œè¿™é‡Œä¹Ÿä¸ä¼šè‡ªåŠ¨å¡«å…¥ï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨è¾“å…¥æ›´ç¨³å¦¥ã€‚

                // C. æ’­æ”¾å¼€åœºçº¢è‰²æŠ¥é”™åŠ¨ç”» (æ»¡è¶³ï¼šå¼€å±æç¤ºé”™è¯¯)
                const introText = document.getElementById('intro-text');
                const introLayer = document.getElementById('intro-layer');
                
                introText.style.opacity = 0;
                
                setTimeout(() => {
                    introText.innerHTML = CONFIG.urlConfig.errorText;
                    introText.className = "breathing error-style"; 
                    introText.style.opacity = 1;
                    
                    introLayer.style.opacity = 1; 
                    introLayer.style.display = 'flex';

                    // åŠ¨ç”»æ’­æ”¾å®Œæ¯•åï¼Œè¿›å…¥ UI å±‚
                    setTimeout(() => {
                        showUILayer();
                    }, CONFIG.urlConfig.errorDuration);
                }, 500);

            } 
            // ã€åˆ†æ”¯äºŒï¼šé“¾æ¥å®Œå…¨æ­£å¸¸ æˆ–è€… æ ¹æœ¬æ²¡å‚æ•°ã€‘
            else {
                // 1. åªæœ‰åœ¨åå­—è§£å‹æˆåŠŸçš„æƒ…å†µä¸‹ï¼Œæ‰è‡ªåŠ¨å¡«å…¥
                if (decodedName && CONFIG.urlConfig.autoFill) {
                    document.getElementById('nameInput').value = decodedName;
                }

                // 2. å†³å®šåœ†ç¯æ˜¾ç¤ºä»€ä¹ˆ
                if (decodedMsg) {
                    // æœ‰éšè—ä¿¡æ¯ -> æ˜¾ç¤ºéšè—ä¿¡æ¯
                    secretMessageText = decodedMsg;
                } else {
                    // æ²¡éšè—ä¿¡æ¯ -> æ˜¾ç¤ºé»˜è®¤å¼•å¯¼è¯­
                    secretMessageText = CONFIG.secret.defaultText;
                }

                // æ­£å¸¸è¿›å…¥
                showUILayer();
            }
        }
 
        function runIntroSequence() {
            const introLayer = document.getElementById('intro-layer');
            const introText = document.getElementById('intro-text');
            const uiLayer = document.getElementById('ui-layer');

            // 1. æ£€æŸ¥ LocalStorage å’Œé…ç½®
            const hasSeen = localStorage.getItem('hasSeenIntro_2026');
            
            // å¦‚æœæ²¡å¼€å¯ï¼Œæˆ–è€…ï¼ˆä¸æ˜¯å¼ºåˆ¶ä¸€ç›´æ˜¾ç¤º ä¸” å·²ç»çœ‹è¿‡äº†ï¼‰ï¼Œåˆ™è·³è¿‡åŠ¨ç”»ç›´æ¥æ£€æŸ¥å‚æ•°
            if (!CONFIG.intro.enabled || (!CONFIG.intro.alwaysShow && hasSeen)) {
                checkUrlAndProceed();
                return;
            }

            // æ ‡è®°å·²è§‚çœ‹
            localStorage.setItem('hasSeenIntro_2026', 'true');

            // 2. å¼€å§‹åŠ¨ç”»æµç¨‹
            let stepIndex = 0;
            const texts = CONFIG.intro.texts;

            function showNextText() {
                if (stepIndex >= texts.length) {
                    // åŠ¨ç”»ç»“æŸ -> æ£€æŸ¥å‚æ•°å¹¶å†³å®šåç»­
                    checkUrlAndProceed();
                    return;
                }

                // åˆ‡æ¢æ–‡å­—
                introText.style.opacity = 0; // å…ˆéš
                setTimeout(() => {
                    introText.innerHTML = texts[stepIndex]; // æ¢å­—
                    introText.style.opacity = 1; // æ˜¾
                    
                    // åœç•™ä¸€æ®µæ—¶é—´å
                    setTimeout(() => {
                        stepIndex++;
                        showNextText(); // é€’å½’è°ƒç”¨
                    }, CONFIG.intro.duration);

                }, CONFIG.intro.fadeSpeed / 2); // æ–‡å­—åˆ‡æ¢çš„å°é—´éš™
            }

            showNextText();
        }
        
        // ===============================================
        // ====== èµ„æºåŠ è½½å™¨ (å­—ä½“ & é€»è¾‘) ======
        // ===============================================
        async function loadGameResources() {
            // 1. åŠ è½½å­—ä½“ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (CONFIG.font.enabled && CONFIG.font.url) {
                try {
                    const customFont = new FontFace(CONFIG.font.family, `url(${CONFIG.font.url})`);
                    await customFont.load();
                    document.fonts.add(customFont);
                    console.log("Custom font loaded:", CONFIG.font.family);
                } catch (err) {
                    console.warn("Font load failed, fallback to system font.", err);
                }
            }

            // 2. å­—ä½“åŠ è½½å®Œæ¯•åï¼Œå†è¿è¡Œå¼€åœºé€»è¾‘ (é˜²æ­¢ measureText æµ‹ä¸å‡†)
            runIntroSequence();
        }

        // é¡µé¢åŠ è½½å®Œæˆåï¼Œå…ˆåŠ è½½èµ„æºï¼Œå†å¯åŠ¨
        window.addEventListener('load', loadGameResources);

        // ===============================================
        // ======èƒŒæ™¯éŸ³ä¹ç®¡ç†å™¨ (Web Audio API) ======
        // ===============================================
        const bgmManager = {
            ctx: null,
            gainNode: null, // éŸ³é‡æ§åˆ¶èŠ‚ç‚¹
            source: null,   // éŸ³é¢‘æº
            buffer: null,   // è§£ç åçš„éŸ³é¢‘æ•°æ®
            isLoaded: false,
            isPlaying: false,

            init() {
                if (!CONFIG.music.enabled || CONFIG.music.files.length === 0) return;
                
                // 1. åˆ›å»º AudioContext (å…¼å®¹ Webkit)
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();

                // 2. åˆ›å»º GainNode (éŸ³é‡æ—‹é’®)
                this.gainNode = this.ctx.createGain();
                // è®¾ç½®åˆå§‹éŸ³é‡
                this.gainNode.gain.value = CONFIG.music.volume;
                // è¿æ¥åˆ°æœ€ç»ˆè¾“å‡º (æ‰¬å£°å™¨)
                this.gainNode.connect(this.ctx.destination);
                
                // 3. éšæœºé€‰æ­Œå¹¶åŠ è½½
                const randomSong = CONFIG.music.files[Math.floor(Math.random() * CONFIG.music.files.length)];
                this.load(randomSong);
            },

            load(url) {
                // ä½¿ç”¨ fetch è·å–éŸ³é¢‘æ–‡ä»¶ (ArrayBuffer)
                fetch(url)
                    .then(response => response.arrayBuffer())
                    .then(arrayBuffer => this.ctx.decodeAudioData(arrayBuffer)) // è§£ç 
                    .then(decodedBuffer => {
                        this.buffer = decodedBuffer;
                        this.isLoaded = true;
                    })
                    .catch(e => console.error("BGM Load Error:", e));
            },

            play() {
                if (!CONFIG.music.enabled || !this.isLoaded) return;
                if (this.isPlaying) return; // é˜²æ­¢é‡éŸ³

                // å¿…é¡»å…ˆ Resume (iOS ç­–ç•¥)
                this.resume();

                // åˆ›å»º BufferSource
                this.source = this.ctx.createBufferSource();
                this.source.buffer = this.buffer;
                this.source.loop = true; // å¾ªç¯æ’­æ”¾

                // å…³é”®ï¼šè¿æ¥åˆ° GainNodeï¼Œè€Œä¸æ˜¯ç›´æ¥è¿ destination
                this.source.connect(this.gainNode);
                
                this.source.start(0);
                this.isPlaying = true;
            },

            setVolume(val) {
                // é™åˆ¶èŒƒå›´ 0~1
                const v = Math.max(0, Math.min(1, parseFloat(val)));
                if (this.gainNode) {
                    // å®æ—¶ä¿®æ”¹ GainNode çš„å€¼ï¼ŒiOS æ— æ³•æ‹¦æˆªè¿™ä¸ªå†…éƒ¨è¿ç®—
                    this.gainNode.gain.value = v;
                }
            },

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            }
        };
        // ç«‹å³åˆå§‹åŒ– BGM
        bgmManager.init();

        // ===============================================
        // ====== éŸ³æ•ˆç®¡ç†å™¨ SoundManager ======
        // ===============================================
        const soundManager = {
            ctx: null,
            buffers: {}, // ç¼“å­˜è§£ç åçš„éŸ³é¢‘æ•°æ®
            sources: CONFIG.sound.files,
            lastSmallBurstTime: 0, // ç”¨äºèŠ‚æµ

            // åˆå§‹åŒ–ï¼šå°è¯•åˆ›å»º AudioContext (éœ€è¦ç”¨æˆ·äº¤äº’åæ‰èƒ½ resume)
            init() {
                // æ³¨æ„ï¼šè¿™é‡Œæˆ‘ä»¬æ€»æ˜¯åˆå§‹åŒ– AudioContextï¼Œå³ä½¿ enabled æš‚æ—¶ä¸º falseï¼Œ
                // å› ä¸ºç”¨æˆ·å¯èƒ½é€šè¿‡ UI æ»‘å—ç¨åå¼€å¯å£°éŸ³ã€‚
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
                    this.preload();
                } catch (e) {
                    console.warn("Web Audio API not supported");
                }
            },

            // é¢„åŠ è½½æ‰€æœ‰éŸ³é¢‘èµ„æº
            preload() {
                if (!this.ctx) return;
                // éå†æ‰€æœ‰ç±»åˆ« (lift, burst, etc.)
                for (const [key, urls] of Object.entries(this.sources)) {
                    this.buffers[key] = [];
                    urls.forEach(url => {
                        fetch(url)
                            .then(response => response.arrayBuffer())
                            .then(arrayBuffer => this.ctx.decodeAudioData(arrayBuffer))
                            .then(decodedBuffer => {
                                this.buffers[key].push(decodedBuffer);
                            })
                            .catch(e => console.warn("Audio load failed:", url));
                    });
                }
            },

            // äº¤äº’è§£é”ï¼šæµè§ˆå™¨é€šå¸¸è¦æ±‚ç”¨æˆ·ç‚¹å‡»åæ‰èƒ½æ’­æ”¾å£°éŸ³
            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },

            // æ’­æ”¾éŸ³æ•ˆæ ¸å¿ƒé€»è¾‘
            playSound(type, scale = 1) {
                // å¦‚æœå¼€å…³æ²¡å¼€ï¼Œæˆ–è€…éŸ³é‡ä¸º0ï¼Œå°±ä¸æ’­
                if (!CONFIG.sound.enabled && CONFIG.sound.volume <= 0.01) return;
                if (!CONFIG.sound.enabled && document.getElementById('sfx-slider').value <= 0) return;

                if (!this.ctx) return;

                // æ£€æŸ¥èµ„æºæ˜¯å¦åŠ è½½å®Œæ¯•
                const bufferList = this.buffers[type];
                if (!bufferList || bufferList.length === 0) return;

                // é˜²çˆ†éŸ³èŠ‚æµ (ä»…é’ˆå¯¹å°ç‚¸è£‚å£°)
                if (type === 'burstSmall') {
                    const now = Date.now();
                    if (now - this.lastSmallBurstTime < 50) return; // 50ms å†·å´
                    this.lastSmallBurstTime = now;
                }

                // éšæœºé€‰æ‹©ä¸€ä¸ªæ ·æœ¬
                const buffer = bufferList[Math.floor(Math.random() * bufferList.length)];
                
                // åˆ›å»ºéŸ³æº
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;

                // åˆ›å»ºéŸ³é‡æ§åˆ¶
                const gainNode = this.ctx.createGain();

                // ç‰©ç†æ¨¡æ‹Ÿè®¡ç®—
                let rate = 1.0;
                let volume = CONFIG.sound.volume;

                if (type === 'burst' || type === 'burstSmall') {
                    // é€Ÿåº¦èŒƒå›´ 0.8 (ä½æ²‰) ~ 1.5 (å°–é”)
                    rate = 1.5 - (scale * 0.5); 
                    // éŸ³é‡èŒƒå›´ 
                    volume = CONFIG.sound.volume * (0.3 + scale * 0.6);
                }

                // é™åˆ¶è¾¹ç•Œ
                rate = Math.max(0.5, Math.min(rate, 2.0));
                volume = Math.max(0.05, Math.min(volume, 1.5));

                source.playbackRate.value = rate;
                gainNode.gain.value = volume;

                // è¿æ¥èŠ‚ç‚¹ï¼šSource -> Gain -> Destination
                source.connect(gainNode);
                gainNode.connect(this.ctx.destination);

                source.start(0);
            }
        };

        // ç«‹å³åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
        soundManager.init();

        // åˆå§‹åŒ–èƒŒæ™¯ç²’å­ (æ”¯æŒå¤šç§å½¢çŠ¶å’Œæ—‹è½¬)
        function initBackground() {
            if (!CONFIG.background.enabled) return;
            bgParticles = [];
            const count = isMobile ? CONFIG.background.countMobile : CONFIG.background.countDesktop;
            
            for (let i = 0; i < count; i++) {
                // å†³å®šå½¢çŠ¶
                let shapeType = 'circle';
                if (CONFIG.background.style === 'mix') {
                    const r = Math.random();
                    if (r < 0.4) shapeType = 'circle';        // 40% å®å¿ƒåœ†
                    else if (r < 0.7) shapeType = 'ring';     // 30% ç©ºå¿ƒåœˆ
                    else shapeType = 'cross';                 // 30% åå­—æ˜Ÿ
                } else {
                    shapeType = CONFIG.background.style;
                }

                bgParticles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    size: CONFIG.background.sizeMin + Math.random() * (CONFIG.background.sizeMax - CONFIG.background.sizeMin),
                    // éšæœºé€Ÿåº¦å‘é‡ (-1 ~ 1) * speed
                    vx: (Math.random() - 0.5) * CONFIG.background.speed,
                    vy: (Math.random() - 0.5) * CONFIG.background.speed,
                    // éšæœºé€æ˜åº¦å·®å¼‚
                    alphaFactor: 0.3 + Math.random() * 0.7,
                    shape: shapeType,
                    rotation: Math.random() * Math.PI, // åˆå§‹æ—‹è½¬è§’åº¦
                    rotSpeed: (Math.random() - 0.5) * 0.02 // è‡ªè½¬é€Ÿåº¦
                });
            }
        }

        // æ›´æ–°å¹¶ç»˜åˆ¶èƒŒæ™¯ (æ”¯æŒæ ·å¼ç»˜åˆ¶)
        function updateAndDrawBackground() {
            if (!CONFIG.background.enabled) return;
            
            ctx.fillStyle = `rgba(${CONFIG.background.color}, 1)`;
            ctx.strokeStyle = `rgba(${CONFIG.background.color}, 1)`;
            ctx.lineWidth = 1.5; // çº¿æ¡ç²—ç»†

            bgParticles.forEach(p => {
                // ç§»åŠ¨
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotSpeed; // è‡ªè½¬
                
                // è¾¹ç•Œå¾ªç¯ (å‡ºå»äº†ä»å¦ä¸€è¾¹å›æ¥)
                if (p.x < -50) p.x = width + 50;
                if (p.x > width + 50) p.x = -50;
                if (p.y < -50) p.y = height + 50;
                if (p.y > height + 50) p.y = -50;
                
                // ç»˜åˆ¶
                ctx.globalAlpha = CONFIG.background.opacity * p.alphaFactor;
                ctx.beginPath();
                
                if (p.shape === 'circle') {
                    // å®å¿ƒåœ†
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                } else if (p.shape === 'ring') {
                    // ç©ºå¿ƒåœˆ (ç”»ç¨å¾®å¤§ä¸€ç‚¹ç‚¹)
                    ctx.arc(p.x, p.y, p.size * 1.2, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (p.shape === 'cross') {
                    // åå­—æ˜Ÿ (å¸¦æ—‹è½¬)
                    ctx.save();
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    const s = p.size * 1.5; 
                    ctx.moveTo(-s, 0); ctx.lineTo(s, 0);
                    ctx.moveTo(0, -s); ctx.lineTo(0, s);
                    ctx.stroke();
                    ctx.restore();
                }
            });
            
            // é‡ç½®é€æ˜åº¦ä»¥å…å½±å“åç»­ç»˜åˆ¶
            ctx.globalAlpha = 1;
        }

        function resize() {
            // é™åˆ¶ DPR æœ€å¤§ä¸º 2ï¼Œä»¥å‡è½»é«˜åˆ†å±ç§»åŠ¨è®¾å¤‡çš„ GPU è´Ÿæ‹…
            dpr = Math.min(window.devicePixelRatio || 1, 2);
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
            ctx.scale(dpr, dpr);
            isMobile = width < 768;
            baseParticleSize = isMobile ? 1.6 : 2.0;

            // åŠ¨æ€åº”ç”¨æŒ‰é’®ä½ç½®
            applyButtonPositions();

            // æ¯æ¬¡è°ƒæ•´çª—å£å¤§å°æ—¶é‡ç½®èƒŒæ™¯
            initBackground();
        }
        window.addEventListener('resize', resize);
        resize();

        function getRandomColor(type) {
            if (type === 'rainbow') return `hsl(${Math.random() * 360}, 90%, 65%)`;
            if (type === 'gold') return `hsl(${35 + Math.random() * 15}, 100%, 60%)`;
            if (type === 'red') return `hsl(${340 + Math.random() * 20}, 100%, 60%)`;
            if (type === 'white') return `hsl(0, 0%, 95%)`; 
            return `hsl(45, 100%, 60%)`; 
        }

        class Particle {
            constructor(x, y) {
                this.x = Math.random() * width;
                this.y = Math.random() * height;
                this.tx = x;
                this.ty = y;
                this.relX = 0;
                this.relY = 0;
                this.color = getRandomColor('gold'); 
                this.alpha = 1;

                this.isTwinkler = CONFIG.twinkle.enabled && (Math.random() < CONFIG.twinkle.probability);
                this.twinklePhase = Math.random() * Math.PI * 2;
                this.twinkleSpeed = CONFIG.twinkle.speedMin + Math.random() * (CONFIG.twinkle.speedMax - CONFIG.twinkle.speedMin);
            }

            update() {
                this.x += (this.tx - this.x) * CONFIG.particleEase;
                this.y += (this.ty - this.y) * CONFIG.particleEase;
                
                if (this.isTwinkler) {
                    this.twinklePhase += this.twinkleSpeed;
                }
            }

            draw(scale = 1, forceX = null, forceY = null, baseAlpha = 1) {
                let currentAlpha = this.alpha * baseAlpha;

                // é”åŒ–çš„å‘¼å¸ç®—æ³•
                if (this.isTwinkler) {
                    const rawSin = Math.sin(this.twinklePhase);
                    const normalizedWave = (rawSin + 1) / 2;
                    const sharpWave = Math.pow(normalizedWave, CONFIG.twinkle.sharpness);
                    const range = CONFIG.twinkle.maxOpacity - CONFIG.twinkle.minOpacity;
                    const twinkleFactor = CONFIG.twinkle.minOpacity + sharpWave * range;
                    currentAlpha *= twinkleFactor;
                }
                
                currentAlpha *= CONFIG.visuals.alphaFactor;

                if (currentAlpha < 0.01) return;

                if (CONFIG.visuals.globalAdditive) {
                    ctx.globalCompositeOperation = 'lighter';
                } else if (this.isTwinkler && CONFIG.visuals.twinkleAdditive) {
                    // ä»…åœ¨æ³¢å³°é«˜äº®æ—¶å¯ç”¨å åŠ 
                    if (currentAlpha > 0.3) {
                            ctx.globalCompositeOperation = 'lighter';
                    } else {
                            ctx.globalCompositeOperation = 'source-over';
                    }
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }

                ctx.globalAlpha = currentAlpha;
                ctx.fillStyle = this.color;
                
                //  ç»˜åˆ¶æŒ‡ä»¤ä¼˜åŒ–ï¼šå°é¢—ç²’ç”¨ fillRectï¼Œå¤§é¢—ç²’ç”¨ arc
                const drawX = forceX !== null ? forceX : this.x;
                const drawY = forceY !== null ? forceY : this.y;
                let s = baseParticleSize * scale;
                s = Math.max(0.5, Math.min(s, baseParticleSize * 4)); 

                if (s < 2) {
                    // å°äº2åƒç´ çš„ç‚¹ï¼Œç›´æ¥ç”»çŸ©å½¢ï¼Œæ€§èƒ½æ›´å¥½
                    ctx.fillRect(drawX - s/2, drawY - s/2, s, s);
                } else {
                    // å¤§ç‚¹ä¿æŒåœ†å½¢ï¼Œè§†è§‰æ•ˆæœå¥½
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, s, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalCompositeOperation = 'source-over'; 
                ctx.globalAlpha = 1;
            }
        }

        // ä¿®æ”¹æ ¸å¿ƒï¼šæ”¯æŒå°æ•°æ­¥é•¿ (Density Control Logic Upgrade)
        // å¢åŠ  font é€»è¾‘
        function sampleText(text, targetFontSize, colorType = 'gold', stepOverride = null) {
            const tmpCanvas = document.createElement('canvas');
            const tCtx = tmpCanvas.getContext('2d');
            
            // å­—ä½“åŠ¨æ€åˆ¤æ–­
            const fontFamily = (CONFIG.font.enabled && CONFIG.font.family) 
                            ? CONFIG.font.family 
                            : '"Microsoft YaHei", sans-serif';

            tCtx.font = `bold ${targetFontSize}px ${fontFamily}`;
            const measure = tCtx.measureText(text);
            let finalSize = targetFontSize;
            const maxW = width * 0.9; 
            if (measure.width > maxW) finalSize = targetFontSize * (maxW / measure.width);
            tmpCanvas.width = width;
            tmpCanvas.height = height;
            tCtx.font = `bold ${finalSize}px ${fontFamily}`;
            tCtx.fillStyle = "white";
            tCtx.textAlign = "center";
            tCtx.textBaseline = "middle";
            tCtx.fillText(text, width / 2, height / 2);
            const idata = tCtx.getImageData(0, 0, width, height);
            const data = idata.data;
            const points = [];
            
            // ç¡®å®šé‡‡æ ·æ­¥é•¿
            let currentStep;
            if (stepOverride) {
                currentStep = stepOverride;
            } else {
                currentStep = isMobile ? CONFIG.density.introMobile : CONFIG.density.introDesktop;
            }
            
            // æ ¸å¿ƒä¿®æ”¹ï¼šä½¿ç”¨ Math.floor æ”¯æŒæµ®ç‚¹æ•°åæ ‡é‡‡æ ·
            for (let y = 0; y < height; y += currentStep) {
                for (let x = 0; x < width; x += currentStep) {
                    // å°†æµ®ç‚¹åæ ‡å–æ•´ï¼Œæ˜ å°„åˆ°åƒç´ æ•°ç»„ç´¢å¼•
                    const inY = Math.floor(y);
                    const inX = Math.floor(x);
                    
                    // è¾¹ç•Œæ£€æŸ¥ï¼Œé˜²æ­¢å°æ•°ç´¯åŠ å¯¼è‡´çš„æº¢å‡º
                    if (inY >= height || inX >= width) continue;

                    if (data[(inY * width + inX) * 4 + 3] > 128) {
                        points.push({ x: inX, y: inY, colorType: colorType });
                    }
                }
            }
            return points;
        }

        // é«˜æ•ˆçš„æ–‡å­—ç‚¹é˜µè·å–å‡½æ•° (æºè‡ª MyMath.literalLattice)
        // ä¸“é—¨ç”¨äºçƒŸèŠ±æ–‡å­—ï¼Œæ€§èƒ½æ¯” sampleText æ›´å¥½ï¼Œä¸”åªç”Ÿæˆæ–‡å­—åŒºåŸŸçš„ç‚¹
        function getTextLattice(text, fontSize) {
            // åˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ç¦»å± canvas
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            
            // å­—ä½“åŠ¨æ€åˆ¤æ–­
            const fontFamily = (CONFIG.font.enabled && CONFIG.font.family) 
                            ? CONFIG.font.family 
                            : '"Microsoft YaHei", sans-serif';

            // 1. å…ˆè®¾ç½®å­—ä½“æ¥æµ‹é‡å®½åº¦
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            const measure = ctx.measureText(text);
            const width = Math.ceil(measure.width);
            const height = fontSize + 20; // ç»™ä¸€ç‚¹é«˜åº¦å†—ä½™é˜²æ­¢è¢«æˆªæ–­

            // 2. è°ƒæ•´ canvas å¤§å°ä¸ºæ–‡å­—å®é™…å¤§å°
            canvas.width = width;
            canvas.height = height;

            // 3. é‡æ–°è®¾ç½®å­—ä½“ (è°ƒæ•´å¤§å°åéœ€è¦é‡è®¾)
            ctx.font = `bold ${fontSize}px ${fontFamily}`;
            ctx.fillStyle = "#ffffff";
            ctx.textBaseline = "middle";
            ctx.textAlign = "left"; // å·¦å¯¹é½æ–¹ä¾¿æ‰«æ

            // 4. ç»˜åˆ¶æ–‡å­—
            ctx.fillText(text, 0, height / 2);

            // 5. è·å–åƒç´ æ•°æ®
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const points = [];

            // 6. é‡‡æ ·å¯†åº¦ (æ ¹æ®è®¾å¤‡è°ƒæ•´ï¼Œæ‰‹æœºç¨€ç–ä¸€ç‚¹)
            // å¯¹åº” user config ä¸­çš„ density æ¦‚å¿µï¼Œä½†è¿™é‡Œæ˜¯å±€éƒ¨é‡‡æ ·
            const density = isMobile ? 2 : 3;

            for (let y = 0; y < height; y += density) {
                for (let x = 0; x < width; x += density) {
                    const i = (y * width + x) * 4;
                    // alpha > 128 è®¤ä¸ºæ˜¯æ–‡å­—éƒ¨åˆ†
                    if (data[i + 3] > 128) {
                        points.push({ x: x, y: y });
                    }
                }
            }

            return {
                width: width,
                height: height,
                points: points
            };
        }

        function createFinalStage() {
            isFinalState = true;
            // æ¸…ç©ºç°æœ‰çš„
            particles = []; staticTopParticles = []; carouselGroups = []; 
            // æ¸…ç©ºç¼“å­˜ç›¸å…³
            charParticleCache = {}; 
            normalizedSecretText = "";

            //  åªæ˜¾ç¤ºåŸæœ¬è¢«éšè—çš„æŒ‰é’®ï¼Œä½†æ’é™¤åˆ†äº«æŒ‰é’®(ç¨åäº¤äº’åå†æ˜¾ç¤º)
            const hiddenBtns = document.querySelectorAll('.initially-hidden');
            hiddenBtns.forEach(btn => {
                //  å¦‚æœæ˜¯åˆ†äº«æŒ‰é’®ï¼Œå…ˆä¸æ˜¾ç¤ºï¼›å…¶ä»–çš„ç«‹å³æ˜¾ç¤º
                if (btn.id !== 'btn-share') {
                    btn.classList.add('reveal-btn');
                }
            });
            
            //  æ˜¾ç¤ºæˆ³æˆ³å±å¹•æç¤º
            if (!hasTouchedInFinal) {
                document.getElementById('touch-hint').style.opacity = 1;
            }

            let topY_Center = height * 0.15; 
            let midY_Center = height * 0.30; 
            let botY_Center = height * 0.45; 
            
            // è·å–é…ç½®çš„å­—ä½“å¤§å°
            let titleSize = isMobile ? CONFIG.fontSizes.finalTitleMobile : CONFIG.fontSizes.finalTitleDesktop;
            let nameSize = isMobile ? CONFIG.fontSizes.finalNameMobile : CONFIG.fontSizes.finalNameDesktop;
            let yearSize = isMobile ? CONFIG.fontSizes.finalYearMobile : CONFIG.fontSizes.finalYearDesktop;
            
            // è·å– Final é˜¶æ®µçš„å¯†åº¦
            const finalStep = isMobile ? CONFIG.density.finalMobile : CONFIG.density.finalDesktop;

            const p1 = sampleText("ç¥", titleSize, 'red', finalStep);
            const p2 = sampleText(userName, nameSize, 'gold', finalStep);
            const p3 = sampleText("2026", yearSize, 'gold', finalStep);

            [...p1, ...p2, ...p3].forEach(p => {
                let part = new Particle(width/2, height/2);
                let targetY = 0;
                if (p1.includes(p)) targetY = p.y - (height/2) + topY_Center;
                else if (p2.includes(p)) targetY = p.y - (height/2) + midY_Center;
                else targetY = p.y - (height/2) + botY_Center;
                part.tx = p.x; part.ty = targetY;
                let cType = 'gold'; if (p1.includes(p)) cType = 'red';
                part.color = getRandomColor(cType);
                part.x = width/2 + (Math.random()-0.5) * 300; 
                part.y = height/2 + (Math.random()-0.5) * 300;
                staticTopParticles.push(part);
            });

            // ====== 1. ç”Ÿæˆæ­£å¸¸æ¨¡å¼åœ†ç¯ (Normal Ring) ======
            let carouselSize = isMobile ? CONFIG.fontSizes.carouselMobile : CONFIG.fontSizes.carouselDesktop;
            let list = CONFIG.carouselTexts;
            
            // è®°å½•æ­£å¸¸åœ†ç¯çš„åŠå¾„ï¼Œç”¨äºåç»­è®¡ç®—é€Ÿåº¦è¡¥å¿
            // æ­£å¸¸åœ†ç¯åŠå¾„æ˜¯åŸºäºé…ç½®çš„æ¯”ä¾‹
            normalRingRadius = isMobile ? width * CONFIG.carouselRadiusRatioMobile : width * CONFIG.carouselRadiusRatioDesktop;

            let angleStep = (Math.PI * 2) / list.length;
            
            list.forEach((text, index) => {
                const points = sampleText(text, carouselSize, 'rainbow', finalStep);
                let group = {
                    baseAngle: -index * angleStep,
                    parts: []
                };
                points.forEach(p => {
                    let part = new Particle(width/2, height + 200);
                    part.relX = -(p.x - width / 2); 
                    part.relY = p.y - height / 2;
                    part.x = (Math.random()-0.5) * width * 1.5; 
                    part.y = height + 200;
                    part.color = getRandomColor('rainbow');
                    group.parts.push(part);
                });
                carouselGroups.push(group);
            });

            // ====== 2. é¢„å¤„ç†éšè—æ¨¡å¼åœ†ç¯æ•°æ® (Secret Ring) - è™šæ‹Ÿå·è½´é€»è¾‘ ======
            if (secretMessageText) {
                // è¯»å–é…ç½®
                const secretSize = isMobile ? CONFIG.secret.font.sizeMobile : CONFIG.secret.font.sizeDesktop;
                
                // ç¡®å®šæ§½ä½æ•°é‡ï¼ˆåœ†ç¯ä¸€åœˆæ˜¾ç¤ºçš„å­—æ•°ï¼‰
                secretSlotCount = isMobile ? CONFIG.secret.ring.slotsMobile : CONFIG.secret.ring.slotsDesktop;
                
                // ç¡®å®šç‰©ç†åŠå¾„
                const radiusRatio = isMobile ? CONFIG.secret.ring.radiusMobile : CONFIG.secret.ring.radiusDesktop;
                secretRingRadius = width * radiusRatio;

                // æ ‡å‡†åŒ–æ–‡æœ¬ï¼šå¦‚æœå­—æ•°å°‘äºæ§½ä½æ•°ï¼Œåˆ™é‡å¤æ‹¼æ¥ï¼Œç›´åˆ°å¡«æ»¡ä¸€åœˆ
                normalizedSecretText = secretMessageText;
                while (normalizedSecretText.length < secretSlotCount) {
                    normalizedSecretText += secretMessageText;
                }

                // ç¼“å­˜å­—ç¬¦ç²’å­æ•°æ®
                // éå†æ¯ä¸€ä¸ªå”¯ä¸€å­—ç¬¦ï¼Œç”Ÿæˆç‚¹é˜µæ•°æ®å­˜å…¥ç¼“å­˜
                for (let char of normalizedSecretText) {
                    if (!charParticleCache[char]) {
                        const lattice = getTextLattice(char, secretSize);
                        const centerX = lattice.width / 2;
                        const centerY = lattice.height / 2;
                        
                        const charParticles = [];
                        lattice.points.forEach(p => {
                            let part = new Particle(width/2, height + 200); // åˆå§‹ä½ç½®æ— å…³ç´§è¦ï¼Œæ¸²æŸ“æ—¶ä¼šé‡ç®—
                            // è®¡ç®—ç›¸å¯¹äºæ–‡å­—ä¸­å¿ƒçš„åç§»
                            part.relX = -(p.x - centerX); 
                            part.relY = p.y - centerY;
                            part.color = getRandomColor('rainbow');
                            charParticles.push(part);
                        });
                        charParticleCache[char] = charParticles;
                    }
                }
            }
        }

        function updateMainText(text) {
            let size = isMobile ? CONFIG.fontSizes.introMobile : CONFIG.fontSizes.introDesktop;
            // å¦‚æœåå­—å¤ªé•¿ï¼Œè‡ªåŠ¨ç¼©å°ä¸€ç‚¹
            if(text.length > 4) size *= 0.7;
            
            const introStep = isMobile ? CONFIG.density.introMobile : CONFIG.density.introDesktop;
            const points = sampleText(text, size, 'gold', introStep);
            
            if (particles.length < points.length) {
                for(let i=0; i<points.length-particles.length; i++) particles.push(new Particle(width/2, height/2));
            } else {
                for(let i=points.length; i<particles.length; i++) particles[i].alpha = 0;
            }
            
            let targetColorMode = CONFIG.textColors.initialMode;
            if (CONFIG.textColors.randomize) {
                const modes = ['gold', 'red', 'rainbow', 'white'];
                targetColorMode = modes[Math.floor(Math.random() * modes.length)];
            }

            points.sort(() => Math.random()-0.5);
            particles.forEach((p, i) => {
                if (i < points.length) {
                    p.tx = points[i].x; 
                    p.ty = points[i].y; 
                    p.alpha = 1; 
                    p.color = getRandomColor(targetColorMode);
                }
            });
        }

        function startShow() {
            const input = document.getElementById('nameInput');
            if (!input.value) return;
            
            //  ç”¨æˆ·äº¤äº’è§¦å‘éŸ³é¢‘è§£é” (iOS/Chrome ç­–ç•¥è¦æ±‚)
            soundManager.resume();
            
            //  å¼€å§‹æ’­æ”¾èƒŒæ™¯éŸ³ä¹
            bgmManager.play();

            userName = input.value;
            document.getElementById('ui-layer').style.opacity = 0;
            setTimeout(() => {
                document.getElementById('ui-layer').style.display = 'none';
                document.getElementById('hint').style.opacity = 1;
            }, 500);
            updateMainText(userName);
            
            // ç»‘å®šç‚¹å‡»å’Œæ‹–æ‹½äº‹ä»¶
            window.addEventListener('mousedown', handleDragStart);
            window.addEventListener('mousemove', handleDragMove);
            window.addEventListener('mouseup', handleDragEnd);

            window.addEventListener('touchstart', handleDragStart, {passive: false});
            window.addEventListener('touchmove', handleDragMove, {passive: false});
            window.addEventListener('touchend', handleDragEnd);

            animate();
        }

        function explodeAndSwitch(nextText) {
            let targets = isFinalState ? staticTopParticles : particles;
            targets.forEach(p => {
                let dx = p.x - width/2; let dy = p.y - height/2;
                p.tx += dx * 0.8; p.ty += dy * 0.8;
            });
            setTimeout(() => {
                if (nextText === "FINAL") createFinalStage(); else updateMainText(nextText);
            }, 300);
        }

        // ===============================================
        // ====== çƒŸèŠ±é€»è¾‘ (Fireworks Logic) ======
        // ===============================================

        // åˆ›å»ºå°¾çƒŸç²’å­
        function createSmoke(x, y) {
            if (!CONFIG.fireworks.smoke.enabled) return;
            
            const size = isMobile ? CONFIG.fireworks.smoke.sizeMobile : CONFIG.fireworks.smoke.sizeDesktop;
            smokeParticles.push({
                x: x + (Math.random() - 0.5) * CONFIG.fireworks.smoke.jitter * 5,
                y: y,
                size: size,
                alpha: 0.5, // åˆå§‹é€æ˜åº¦
                vx: (Math.random() - 0.5) * 0.3, // è½»å¾®é£˜åŠ¨
                vy: (Math.random() * 0.5),       // è½»å¾®ä¸‹æ²‰
                decay: CONFIG.fireworks.smoke.decaySpeed
            });
        }

        // æ›´æ–°å¹¶ç»˜åˆ¶å°¾çƒŸ
        function updateAndDrawSmoke() {
            if (!CONFIG.fireworks.smoke.enabled) return;

            ctx.fillStyle = `rgba(${CONFIG.fireworks.smoke.color}, 1)`;
            
            for (let i = smokeParticles.length - 1; i >= 0; i--) {
                let s = smokeParticles[i];
                s.x += s.vx;
                s.y += s.vy;
                s.alpha -= s.decay;
                
                if (s.alpha <= 0) {
                    smokeParticles.splice(i, 1);
                    continue;
                }
                
                ctx.globalAlpha = s.alpha;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        function launchFirework(targetX, targetY) {
            // è§¦å‘å‘å°„éŸ³æ•ˆ (lift)
            soundManager.playSound('lift', 1);

            // å‘å°„ä¸€ä¸ªâ€œç«ç®­â€
            const speed = isMobile ? CONFIG.fireworks.launchSpeedMobile : CONFIG.fireworks.launchSpeedDesktop;
            fireworks.push({
                x: targetX, // ä»ç‚¹å‡»çš„Xè½´æ­£ä¸‹æ–¹å‘å°„ (åˆå§‹X)
                baseX: targetX, // è®°å½•åŸºå‡†çº¿ï¼Œç”¨äºè®¡ç®—æŠ–åŠ¨
                y: height,  // å±å¹•åº•éƒ¨
                tx: targetX,
                ty: targetY,
                speed: speed,
                color: getRandomColor('rainbow'), // éšæœºé¢œè‰²
                wobblePhase: Math.random() * Math.PI * 2, // åˆå§‹æŠ–åŠ¨ç›¸ä½
                tick: 0 // ç”¨äºæ§åˆ¶å°¾çƒŸç”Ÿæˆé¢‘ç‡
            });
        }

        // çˆ†ç‚¸é€»è¾‘ - æ”¯æŒå›¾æ¡ˆå’Œæ–‡å­—
        function createExplosion(x, y, color) {
            // 1. åˆ¤æ–­æ˜¯å¦è§¦å‘æ–‡å­—çƒŸèŠ± (æ¦‚ç‡è§¦å‘)
            const textCfg = CONFIG.fireworks.textFireworks;
            if (textCfg.enabled && Math.random() < textCfg.probability) {
                createWordExplosion(x, y);
                return; // â˜… å¦‚æœæ˜¯æ–‡å­—çƒŸèŠ±ï¼Œå°±ä¸è¦å†äº§ç”Ÿæ™®é€šç«èŠ±äº†
            }

            // 2. å¦‚æœä¸æ˜¯æ–‡å­—ï¼Œåˆ™ä½¿ç”¨å‡ ä½•å›¾æ¡ˆçˆ†ç‚¸
            const count = isMobile ? CONFIG.fireworks.explosionCountMobile : CONFIG.fireworks.explosionCountDesktop;
            const scaleMul = isMobile ? CONFIG.fireworks.patterns.scaleMobile : CONFIG.fireworks.patterns.scaleDesktop;
            
            //  è§¦å‘æ™®é€šçˆ†ç‚¸éŸ³æ•ˆ (burst)
            // æ ¹æ® scaleMul è°ƒæ•´éŸ³è°ƒã€‚scaleMul è¶Šå¤§ï¼Œscale è¶Šå¤§ï¼Œå£°éŸ³è¶Šä½æ²‰ã€‚
            // è¿™é‡Œå°† scaleMul å½’ä¸€åŒ–åˆ° 0.8~1.2 å·¦å³ä¼ ç»™ playSound
            soundManager.playSound('burst', isMobile ? scaleMul / 1.5 : scaleMul / 2.0);

            // å†³å®šå½“å‰è¿™ä¸ªçƒŸèŠ±çš„å½¢çŠ¶
            let patternType = 'sphere'; // é»˜è®¤åœ†å½¢
            if (CONFIG.fireworks.patterns.enabled) {
                const r = Math.random();
                if (r < 0.5) patternType = 'sphere';        // 50% æ­£å¸¸åœ†å½¢
                else if (r < 0.75) patternType = 'ring';    // 25% ç¯å½¢
                else patternType = 'burst';                 // 25% ç‚¸è£‚æ˜Ÿå½¢
            }

            for (let i = 0; i < count; i++) {
                let angle, speed;

                if (patternType === 'ring') {
                    // ç¯å½¢ï¼šè§’åº¦éšæœºï¼Œé€Ÿåº¦å›ºå®š
                    angle = Math.random() * Math.PI * 2;
                    speed = CONFIG.fireworks.explosionForce * 0.8 * scaleMul; // ç¯å½¢ç¨å¾®æ•´é½ç‚¹
                } else if (patternType === 'burst') {
                    // æ˜Ÿå½¢ï¼šåˆ†å‡ æŸ
                    const arms = 8;
                    const armAngle = (Math.PI * 2) / arms;
                    const fuzzy = (Math.random() - 0.5) * 0.5; // ç¨å¾®æ•£å¼€ç‚¹
                    const baseAngle = Math.floor(Math.random() * arms) * armAngle;
                    angle = baseAngle + fuzzy;
                    speed = Math.random() * CONFIG.fireworks.explosionForce * 1.2 * scaleMul;
                } else {
                    // é»˜è®¤çƒå½¢ï¼šå®Œå…¨éšæœº
                    angle = Math.random() * Math.PI * 2;
                    speed = Math.random() * CONFIG.fireworks.explosionForce * scaleMul;
                }

                sparks.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    alpha: 1,
                    decay: CONFIG.fireworks.decayMin + Math.random() * (CONFIG.fireworks.decayMax - CONFIG.fireworks.decayMin), 
                    color: color,
                    isText: false // æ ‡è®°è¿™ä¸æ˜¯æ–‡å­—ç²’å­
                });
            }
        }

        //  æ–‡å­—çˆ†ç‚¸é€»è¾‘ -ï¼šç”±ä¸­å¿ƒå‘å¤–ç‚¸å¼€ (ä½¿ç”¨ç§»æ¤çš„ getTextLattice ç®—æ³•)
        function createWordExplosion(cx, cy) {
            // è§¦å‘æ–‡å­—çƒŸèŠ±éŸ³æ•ˆ (burstSmall)
            // æ–‡å­—çƒŸèŠ±é€šå¸¸å¯†é›†ï¼Œä½¿ç”¨èŠ‚æµçš„ burstSmall
            soundManager.playSound('burstSmall', 1.0);

            const cfg = CONFIG.fireworks.textFireworks;
            const word = cfg.words[Math.floor(Math.random() * cfg.words.length)];
            
            // å­—ä½“å¤§å° (å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ï¼Œå› ä¸ºç¦»å± Canvas ä¸å—å±å¹•é™åˆ¶)
            const fontSize = isMobile ? 60 : 100; 
            
            //  ä½¿ç”¨æ–°å‡½æ•°è·å–ç‚¹é˜µï¼Œæ›¿æ¢åŸæ¥çš„ sampleText è°ƒç”¨
            // è¿™é‡Œçš„ lattice åŒ…å« {width, height, points: [{x,y}]}
            const lattice = getTextLattice(word, fontSize);
            
            //  ç¡®å®šæ–‡å­—é¢œè‰² - ä¿è¯å•å­—çº¯è‰²
            let explosionColor = 'hsl(45, 100%, 60%)'; // é»˜è®¤é‡‘
            if (cfg.colorMode === 'random') {
                // éšæœºå–ä¸€ä¸ªå½©è™¹è‰²ï¼Œä½†å…¨å­—ç»Ÿä¸€
                explosionColor = getRandomColor('rainbow');
            } else if (cfg.colorMode === 'fixed') {
                explosionColor = `rgb(${cfg.fixedColor})`;
            } else {
                // 'gold'
                explosionColor = getRandomColor('gold');
            }

            // è·å–ç‚¸å¼€åŠ›åº¦æ¯”ä¾‹
            const scaleForce = isMobile ? cfg.explosionScaleMobile : cfg.explosionScaleDesktop;

            // è®¡ç®—ä¸­å¿ƒåç§»é‡ï¼Œè®©æ–‡å­—åœ¨ cx, cy å¤„å±…ä¸­ç‚¸å¼€
            const centerX = lattice.width / 2;
            const centerY = lattice.height / 2;

            lattice.points.forEach(p => {
                // p.x, p.y æ˜¯åœ¨å° canvas é‡Œçš„åæ ‡
                // éœ€è¦è®¡ç®—ç›¸å¯¹äºæ–‡å­—ä¸­å¿ƒçš„åç§»
                const relX = p.x - centerX;
                const relY = p.y - centerY;
                
                sparks.push({
                    x: cx, 
                    y: cy,
                    // é€Ÿåº¦ = è·ç¦» * ç³»æ•°ã€‚è¿™æ ·è¿œçš„ç²’å­é£å¾—å¿«ï¼Œè¿‘çš„é£å¾—æ…¢ï¼Œæœ€ç»ˆåŒæ—¶åˆ°è¾¾å½¢çŠ¶
                    // 0.08 æ˜¯ä¸ªç»éªŒç³»æ•°ï¼Œè®©å®ƒç‚¸å¾—è‡ªç„¶ç‚¹
                    vx: relX * scaleForce * 0.08, 
                    vy: relY * scaleForce * 0.08,
                    alpha: 1,
                    decay: cfg.decaySpeed, // æ–‡å­—æ¶ˆå¤±å¾—æ…¢ä¸€ç‚¹
                    color: explosionColor, // ä½¿ç”¨ç»Ÿä¸€é¢œè‰²
                    isText: true, // æ ‡è®°ä¸ºæ–‡å­—ç²’å­
                    size: isMobile ? cfg.particleSizeMobile : cfg.particleSizeDesktop
                });
            });
        }

        function updateAndDrawFireworks() {
            //  å…ˆç”»å°¾çƒŸï¼Œè®©å®ƒåœ¨ç«èŠ±ä¸‹é¢
            updateAndDrawSmoke();

            // 1. æ›´æ–°ä¸Šå‡çš„çƒŸèŠ±
            for (let i = fireworks.length - 1; i >= 0; i--) {
                let fw = fireworks[i];
                fw.y -= fw.speed;
                
                //  è®¡ç®—é£è¡ŒæŠ–åŠ¨ (Så‹ä¸Šå‡)
                fw.wobblePhase += 0.15; // æŠ–åŠ¨é¢‘ç‡
                const wobbleOffset = Math.sin(fw.wobblePhase) * CONFIG.fireworks.ascentWobble;
                const currentX = fw.baseX + wobbleOffset;
                fw.x = currentX;

                // ç”Ÿæˆå°¾çƒŸ
                fw.tick++;
                if (fw.tick % CONFIG.fireworks.smoke.interval === 0) {
                    createSmoke(currentX, fw.y + 10); // åœ¨ç«ç®­å°¾éƒ¨ç”Ÿæˆ
                }

                // ç»˜åˆ¶æ‹–å°¾
                ctx.beginPath();
                // æ‹–å°¾ä¹Ÿç¨å¾®å¸¦ç‚¹æŠ–åŠ¨æ„Ÿ
                ctx.moveTo(currentX, fw.y + fw.speed * 1.5);
                ctx.lineTo(currentX, fw.y);
                ctx.strokeStyle = fw.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // åˆ°è¾¾ç›®æ ‡é«˜åº¦ï¼Ÿçˆ†ç‚¸ï¼
                if (fw.y <= fw.ty) {
                    createExplosion(fw.baseX, fw.y, fw.color); // åœ¨åŸºå‡†Xå¤„çˆ†ç‚¸ï¼Œé˜²æ­¢åç¦»
                    fireworks.splice(i, 1);
                }
            }

            // 2. æ›´æ–°çˆ†ç‚¸çš„ç«èŠ±
            for (let i = sparks.length - 1; i >= 0; i--) {
                let s = sparks[i];
                s.x += s.vx;
                s.y += s.vy;
                
                // æ–‡å­—ç²’å­å—é‡åŠ›å½±å“å°ä¸€ç‚¹ï¼Œå¦åˆ™å­—ä¼šæ²‰ä¸‹å»
                if (s.isText) {
                      s.vy += CONFIG.fireworks.gravity * 0.3; 
                      s.vx *= 0.92; // æ–‡å­—ç²’å­é˜»åŠ›å¤§ï¼Œä¸ºäº†ä¿æŒå½¢çŠ¶
                      s.vy *= 0.92;
                } else {
                      s.vy += CONFIG.fireworks.gravity; 
                      s.vx *= CONFIG.fireworks.friction; 
                      s.vy *= CONFIG.fireworks.friction;
                }
                
                s.alpha -= s.decay;

                if (s.alpha <= 0) {
                    sparks.splice(i, 1);
                } else {
                    ctx.globalAlpha = s.alpha;
                    ctx.fillStyle = s.color;
                    ctx.beginPath();
                    // æ–‡å­—ç²’å­å¤§å°å¯æ§ï¼Œæ™®é€šç²’å­ç”¨åŸæ¥çš„å¤§å°
                    let pSize = s.isText ? s.size : (isMobile ? 1.5 : 2);
                    ctx.arc(s.x, s.y, pSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1; // æ¢å¤
        }

        // ===============================================
        // ====== UI äº¤äº’é€»è¾‘ ======
        // ===============================================

        function toggleAutoFire() {
            const btn = document.getElementById('btn-auto');
            if (isAutoFiring) {
                isAutoFiring = false;
                btn.innerText = "è‡ªåŠ¨æ”¾çƒŸèŠ±: å…³";
                btn.classList.remove('active');
                clearTimeout(autoFireTimer);
            } else {
                isAutoFiring = true;
                btn.innerText = "è‡ªåŠ¨æ”¾çƒŸèŠ±: å¼€";
                btn.classList.add('active');
                scheduleNextFirework();
            }
        }

        function scheduleNextFirework() {
            if (!isAutoFiring) return;
            const delay = CONFIG.ui.autoFire.minInterval + Math.random() * (CONFIG.ui.autoFire.maxInterval - CONFIG.ui.autoFire.minInterval);
            autoFireTimer = setTimeout(() => {
                if (!isAutoFiring) return;
                
                //  æ”¯æŒå¹¶å‘ (ä¸€æ¬¡æ”¾å¥½å‡ ä¸ª)
                const burstCount = Math.floor(Math.random() * CONFIG.ui.autoFire.maxConcurrent) + 1;
                
                for(let k=0; k<burstCount; k++) {
                    const targetX = width * 0.1 + Math.random() * width * 0.8;
                    const targetY = height * 0.1 + Math.random() * height * 0.4; // åä¸Šæ–¹ç‚¸
                    launchFirework(targetX, targetY);
                }
                
                scheduleNextFirework();
            }, delay);
        }

        function reloadPage() {
            location.reload();
        }

        function goBlog() {
            window.location.href = CONFIG.ui.blogUrl;
        }

        // éŸ³é‡ UI äº¤äº’å‡½æ•° - æ§åˆ¶ç«–å‘é¢æ¿æ˜¾ç¤º
        function toggleVolumePanel() {
            const panel = document.getElementById('volume-panel-vertical');
            panel.classList.toggle('show');
        }

        function updateBgmVolume(val) {
            CONFIG.music.volume = parseFloat(val);
            bgmManager.setVolume(CONFIG.music.volume);
        }

        function updateSfxVolume(val) {
            CONFIG.sound.volume = parseFloat(val);
            // é¡ºä¾¿å¦‚æœéŸ³é‡å¤§äº0ï¼Œå¼€å¯éŸ³æ•ˆ enabledï¼Œå¦åˆ™å…³é—­ï¼Œä¼˜åŒ–æ€§èƒ½
            CONFIG.sound.enabled = (CONFIG.sound.volume > 0.01);
        }

        // ===============================================
        // ======  ç•™è¨€åˆ†äº«ç›¸å…³é€»è¾‘ (SHARE LOGIC)  ======
        // ===============================================
        function openShareModal() {
            const overlay = document.getElementById('share-overlay');
            overlay.classList.add('show');
            
            // æ¸…ç©ºä¹‹å‰çš„è¾“å…¥å’Œç»“æœ
            document.getElementById('share-name-input').value = "";
            document.getElementById('share-msg-input').value = "";
            document.getElementById('share-link-output').value = "";
            document.getElementById('share-result').style.display = 'none';
        }

        function closeShareModal() {
            document.getElementById('share-overlay').classList.remove('show');
        }

        function generateShareLink() {
            const nameVal = document.getElementById('share-name-input').value.trim();
            const msgVal = document.getElementById('share-msg-input').value.trim();
            
            const baseUrl = CONFIG.ui.share.baseUrl;
            const paramNameA = CONFIG.ui.share.paramName;
            const paramNameM = CONFIG.secret.paramNameMsg;
            
            // æ£€æŸ¥ LZString æ˜¯å¦åŠ è½½
            if (typeof LZString === 'undefined') {
                alert("èµ„æºåº“åŠ è½½ä¸­ï¼Œè¯·ç¨åå†è¯•...");
                return;
            }

            let params = [];

            // 1. å‹ç¼©åå­—
            if (nameVal) {
                try {
                    const compressedName = LZString.compressToEncodedURIComponent(nameVal);
                    params.push(`${paramNameA}=${compressedName}`);
                } catch (e) { console.error("Name Compression Failed", e); }
            }

            // 2. å‹ç¼©å¯†è¯­
            if (msgVal) {
                try {
                    const compressedMsg = LZString.compressToEncodedURIComponent(msgVal);
                    params.push(`${paramNameM}=${compressedMsg}`);
                } catch (e) { console.error("Msg Compression Failed", e); }
            }

            // 3. æ‹¼æ¥é“¾æ¥
            let finalLink = baseUrl;
            if (params.length > 0) {
                const separator = baseUrl.includes('?') ? '&' : '?';
                finalLink = `${baseUrl}${separator}${params.join('&')}`;
            }

            // æ˜¾ç¤ºç»“æœåˆ°æ–‡æœ¬æ¡†
            const outputEl = document.getElementById('share-link-output');
            outputEl.value = finalLink;
            document.getElementById('share-result').style.display = 'block';
            
            // è‡ªåŠ¨å…¨é€‰æ–‡æœ¬ï¼Œæ–¹ä¾¿å¤åˆ¶
            outputEl.select();
            outputEl.setSelectionRange(0, 99999); // å…¼å®¹ç§»åŠ¨ç«¯
        }

        // ===============================================
        // ====== æƒ¯æ€§æ‹–æ‹½ä¸ç‚¹å‡»é€»è¾‘ (Interactive) ======
        // ===============================================
        
        // ç»Ÿä¸€è·å– X åæ ‡
        function getClientX(e) {
            return e.touches ? e.touches[0].clientX : e.clientX;
        }

        // è·å– Y åæ ‡ (ç”¨äºè¯¯è§¦åˆ¤æ–­)
        function getClientY(e) {
            return e.touches ? e.touches[0].clientY : e.clientY;
        }

        function handleDragStart(e) {
            // æ’é™¤UIå…ƒç´ çš„ç‚¹å‡» (åŒ…æ‹¬æ–°çš„å¼¹çª—ç›¸å…³)
            if (e.target.tagName === 'BUTTON' || 
                e.target.tagName === 'INPUT' || 
                e.target.tagName === 'TEXTAREA' ||
                e.target.closest('.volume-container') || 
                e.target.closest('#share-overlay')) return;

            //  äº¤äº’æ—¶å°è¯•è§£é” AudioContext
            soundManager.resume();
            bgmManager.resume();

            // å¦‚æœæ˜¯ Touch äº‹ä»¶ï¼Œé˜²æ­¢æ»šåŠ¨
            if (e.type === 'touchstart') {
                 // ä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå¯èƒ½ä¼šå¯¼è‡´é¡µé¢æ»šåŠ¨ï¼Œä½†åœ¨å…¨å± canvas ä¸Šé€šå¸¸éœ€è¦ preventDefault
                 // ä¸è¿‡ä¸ºäº†å…¼å®¹æ€§ï¼Œè¿™é‡Œç¨å¾®å®½å®¹ä¸€ç‚¹ï¼Œåªåœ¨ move æ—¶é˜»æ­¢
            }

            const clientY = getClientY(e);
            const safeZone = isMobile ? CONFIG.ui.safeZoneHeightMobile : CONFIG.ui.safeZoneHeightDesktop;
            
            // å¦‚æœç‚¹å‡»åœ¨åº•éƒ¨å®‰å…¨åŒºå†…ï¼Œç›´æ¥å¿½ç•¥ï¼ˆä¸æ”¾çƒŸèŠ±ï¼Œä¸æ‹–æ‹½ï¼‰
            if (height - clientY < safeZone) return;

            // 1. å¦‚æœæ˜¯ Final é˜¶æ®µï¼Œä¼˜å…ˆå¤„ç†æ‹–æ‹½
            if (isFinalState) {
                dragState.isDragging = true;
                dragState.startX = getClientX(e);
                dragState.lastX = dragState.startX;
                dragState.velocity = 0; // é‡ç½®é€Ÿåº¦
            }
            
            // 2. å¦‚æœä¸æ˜¯ Final é˜¶æ®µï¼Œæˆ–è€…å•çº¯ç‚¹å‡»ï¼Œè®°å½•ç‚¹å‡»é€»è¾‘äº¤ç»™ handleClick (è¿™é‡Œå®é™…ä¸Šå¯ä»¥åˆå¹¶)
            if (!isFinalState) {
                handleClickLogic(e);
            }
        }

        function handleDragMove(e) {
            if (!dragState.isDragging || !isFinalState) return;
            e.preventDefault(); // é˜²æ­¢æ‹–æ‹½æ—¶é¡µé¢æ»šåŠ¨

            const x = getClientX(e);
            const delta = x - dragState.lastX;
            dragState.lastX = x;

            // è®¡ç®—æ‹–æ‹½äº§ç”Ÿçš„é€Ÿåº¦ = ç§»åŠ¨è·ç¦» * çµæ•åº¦
            // æ³¨æ„ï¼šå› ä¸ºåŸæœ¬ logic æ˜¯ globalRotation -= speedï¼Œè¿™é‡Œ delta > 0 (å‘å³æ‹–) åº”è¯¥è®© rotation å˜å°è¿˜æ˜¯å˜å¤§ï¼Ÿ
            // è¯•ä¸€ä¸‹ï¼šå‘å³æ‹–å¸Œæœ›ç‰©ä½“å‘å³è½¬ -> é¡ºæ—¶é’ˆ -> è§’åº¦å‡å°ï¼Ÿ
            // é€šå¸¸ Canvas 3D è®¡ç®—ï¼šx3d = p.relX * cosA + radius * sinA
            // è°ƒæ•´ç¬¦åˆç›´è§‰å³å¯ã€‚è¿™é‡Œè®¾å®šï¼šå‘å³æ‹–ï¼Œç‰©ä½“è·Ÿç€å‘å³è½¬ã€‚
            
            dragState.velocity = delta * CONFIG.interaction.inertia.dragSensitivity;
        }

        function handleDragEnd(e) {
            if (isFinalState && dragState.isDragging) {
                dragState.isDragging = false;
                
                // åˆ¤æ–­æ˜¯å¦æ˜¯â€œç‚¹å‡»â€è€Œéâ€œæ‹–æ‹½â€
                // å¦‚æœç§»åŠ¨è·ç¦»å¾ˆå°ï¼Œè§†ä¸ºç‚¹å‡» -> æ”¾çƒŸèŠ±
                const totalDist = Math.abs(dragState.lastX - dragState.startX);
                if (totalDist < 10) {
                      // è§†ä¸ºç‚¹å‡»ï¼Œæ”¾çƒŸèŠ±
                      // éœ€è¦è·å–ç»“æŸæ—¶çš„åæ ‡ï¼ŒtouchEnd æ²¡æœ‰ touchesï¼ŒchangedTouches æœ‰
                      let clientX, clientY;
                      if (e.changedTouches) {
                          clientX = e.changedTouches[0].clientX;
                          clientY = e.changedTouches[0].clientY;
                      } else {
                          clientX = e.clientX;
                          clientY = e.clientY;
                      }
                      
                      // ç¬¬ä¸€æ¬¡ç‚¹å‡»éšè—æç¤º
                      if (!hasTouchedInFinal) {
                        hasTouchedInFinal = true;
                        document.getElementById('touch-hint').style.opacity = 0;

                        // ä»…å½“æ²¡æœ‰éšè—å½©è›‹æ—¶ï¼Œæ‰ç«‹å³æ˜¾ç¤ºåˆ†äº«æŒ‰é’®
                        // å¦‚æœæœ‰å½©è›‹ï¼ŒæŒ‰é’®ä¼šåœ¨ animate å‡½æ•°ä¸­æ£€æµ‹åˆ°è§£é”æˆåŠŸåæ˜¾ç¤º
                        if (!secretMessageText) {
                            setTimeout(() => {
                                const shareBtn = document.getElementById('btn-share');
                                if (shareBtn) shareBtn.classList.add('reveal-btn');
                            }, 500); 
                        }
                    }
                    launchFirework(clientX, clientY);
                }
            }
            dragState.isDragging = false;
        }

        // åŸæœ‰ç‚¹å‡»é€»è¾‘çš„å°è£… (ç”¨äºé Final é˜¶æ®µçš„åœºæ™¯åˆ‡æ¢)
        let isAnimating = false;
        function handleClickLogic(e) {
            if (isAnimating) return;
            isAnimating = true; step++;
            document.getElementById('hint').style.opacity = 0;
            if (step <= CONFIG.transitionTexts.length) {
                explodeAndSwitch(CONFIG.transitionTexts[step-1]);
                setTimeout(() => {
                    isAnimating = false; document.getElementById('hint').style.opacity = 1;
                }, 1800);
            } else {
                explodeAndSwitch("FINAL");
            }
        }

        function animate() {
            ctx.clearRect(0, 0, width, height);
            
            //  åœ¨æ¸…ç©ºç”»å¸ƒåã€ç»˜åˆ¶ä¸»è¦æ–‡å­—å‰ï¼Œå…ˆç”»èƒŒæ™¯
            // è¿™æ ·èƒŒæ™¯æ°¸è¿œåœ¨æœ€åé¢ï¼Œä¸ä¼šé®æŒ¡æ–‡å­—
            updateAndDrawBackground();

            // ç»˜åˆ¶çƒŸèŠ±ï¼ˆå»ºè®®æ”¾åœ¨èƒŒæ™¯ä¹‹ä¸Šï¼Œæ–‡å­—ä¹‹ä¸‹ï¼Œæˆ–è€…æ–‡å­—ä¹‹ä¸Šéƒ½å¯ä»¥ï¼‰
            // è¿™é‡Œæ”¾åœ¨æ–‡å­—å±‚ä¸‹é¢ä¸€ç‚¹ç‚¹ï¼Œæˆ–è€…ç”¨ lighter æ··åˆæ¨¡å¼è®©å®ƒæ›´äº®
            ctx.globalCompositeOperation = 'lighter';
            updateAndDrawFireworks();
            ctx.globalCompositeOperation = 'source-over'; 

            if (!isFinalState) {
                particles.forEach(p => { 
                    p.update(); 
                    if(p.alpha > 0.01) p.draw(1); 
                });
            } else {
                staticTopParticles.forEach(p => { 
                    p.update(); 
                    p.draw(1); 
                });

                // --- æ ¸å¿ƒä¿®æ”¹ï¼šæƒ¯æ€§ç‰©ç†é€»è¾‘ ---
                let currentAbsSpeed = 0;
                
                if (dragState.isDragging) {
                    // 1. æ‹–æ‹½ä¸­ï¼šç›´æ¥åº”ç”¨æ‹–æ‹½é€Ÿåº¦ï¼Œå¹¶è¦†ç›–åŸºç¡€è‡ªè½¬
                    // è¿™é‡Œä¸ºäº†æ‰‹æ„Ÿï¼Œåå‘åº”ç”¨ï¼Œå› ä¸º globalRotation æ˜¯ -=
                    globalRotation -= dragState.velocity;
                    currentAbsSpeed = Math.abs(dragState.velocity);
                } else {
                    // 2. æ¾æ‰‹åï¼šæƒ¯æ€§ + æ¢å¤

                    // A. åº”ç”¨æ‘©æ“¦åŠ›è¡°å‡
                    dragState.velocity *= CONFIG.interaction.inertia.friction;

                    // B. é€Ÿåº¦å½’é›¶åˆ¤å®š
                    if (Math.abs(dragState.velocity) < 0.0001) {
                          dragState.velocity = 0;
                    }

                    // C. åº”ç”¨æ—‹è½¬
                    globalRotation += CONFIG.rotationSpeed; 
                    globalRotation -= dragState.velocity; 

                    // D. è®¡ç®—å½“å‰ç»å¯¹é€Ÿåº¦
                    currentAbsSpeed = Math.abs(CONFIG.rotationSpeed - dragState.velocity);
                }
                
                // ============================================
                // ====== ç§˜å¯†åˆ‡æ¢é€»è¾‘ (Switch Logic) ======
                // ============================================
                const touchHintEl = document.getElementById('touch-hint');
                const switchThreshold = CONFIG.secret.thresholds.switch;
                const hintThreshold = CONFIG.secret.thresholds.hint;
                const stopThreshold = CONFIG.secret.thresholds.stop;

                if (secretMessageText) {
                    // 1. æ£€æµ‹æ˜¯å¦è§¦å‘åˆ‡æ¢ (é€Ÿåº¦æå¿« + å­˜åœ¨å¯†è¯­ + å½“å‰æ˜¯ NORMAL çŠ¶æ€)
                    if (renderState === 'NORMAL' && currentAbsSpeed > switchThreshold) {
                        // åˆ‡æ¢åˆ°â€œæ­æ™“ä¸­â€çŠ¶æ€
                        renderState = 'REVEALING';
                        
                        // é€Ÿåº¦è¡¥å¿ï¼šç¼©å°è§’é€Ÿåº¦ï¼Œä¿æŒçº¿é€Ÿåº¦æ’å®š
                        // è¿™æ ·å¤§åœ†ç¯å‡ºç°æ—¶å°±ä¸ä¼šçªç„¶è½¬å¾—é£å¿«
                        if (!hasSwitchedRadius && secretRingRadius > 0 && normalRingRadius > 0) {
                            const ratio = normalRingRadius / secretRingRadius;
                            dragState.velocity *= ratio; // è¡¥å¿æ‹–æ‹½æƒ¯æ€§
                            // æ ‡è®°å·²è¡¥å¿ï¼Œé˜²æ­¢é‡å¤è®¡ç®—
                            hasSwitchedRadius = true;
                        }

                        // æ˜¾ç¤ºæç¤ºï¼šä¸ç”¨è½¬äº†
                        if (hasTouchedInFinal) { 
                            touchHintEl.innerText = CONFIG.secret.hints.slowDown;
                            touchHintEl.style.opacity = 1;
                        }
                    } 
                    // 2. æ­æ™“ä¸­çŠ¶æ€ï¼šç­‰å¾…é€Ÿåº¦é™ä¸‹æ¥
                    else if (renderState === 'REVEALING') {
                        // å¦‚æœé€Ÿåº¦å·²ç»å¾ˆæ…¢äº†ï¼ˆæ¥è¿‘æ­£å¸¸è‡ªè½¬é€Ÿåº¦ï¼‰ï¼Œåˆ™æ­£å¼åˆ‡æ¢ä¸º SECRET
                        if (currentAbsSpeed < stopThreshold * 3) {
                            renderState = 'SECRET';
                            
                            // éšè—æç¤º
                            touchHintEl.style.opacity = 0;
                            
                            // å»¶è¿Ÿä¸€ç‚¹æ˜¾ç¤ºåˆ†äº«æŒ‰é’® (å¦‚æœè¿˜æ²¡æ˜¾ç¤ºçš„è¯)
                            const shareBtn = document.getElementById('btn-share');
                            if (shareBtn && !shareBtn.classList.contains('reveal-btn')) {
                                setTimeout(() => shareBtn.classList.add('reveal-btn'), 500);
                            }
                        }
                    }
                    // 3. æ­£å¸¸çŠ¶æ€ä¸‹çš„æç¤ºé€»è¾‘ (è¿˜æœªè§¦å‘æé€Ÿ)
                    else if (renderState === 'NORMAL' && hasTouchedInFinal) {
                        if (currentAbsSpeed > hintThreshold) {
                            touchHintEl.innerText = CONFIG.secret.hints.faster;
                            touchHintEl.style.opacity = 1;
                        } else {
                            touchHintEl.innerText = CONFIG.secret.hints.start;
                            touchHintEl.style.opacity = 1;
                        }
                    }
                }

                // ============================================

                // æ ¹æ®å½“å‰æ˜¾ç¤ºçš„æ˜¯æ™®é€šåœ†ç¯è¿˜æ˜¯å·¨å‹åœ†ç¯ï¼Œå†³å®šåŠå¾„
                // åªæœ‰å®Œå…¨è¿›å…¥ REVEALING æˆ– SECRET çŠ¶æ€ï¼Œä¸”ç¡®å®æœ‰éšè—è¯ç»„ï¼Œæ‰ä½¿ç”¨å·¨å‹åŠå¾„
                const shouldUseSecretRadius = (renderState !== 'NORMAL' && normalizedSecretText.length > 0);
                
                let currentRadius = 0;
                if (shouldUseSecretRadius) {
                    currentRadius = secretRingRadius;
                } else {
                    currentRadius = isMobile ? width * CONFIG.carouselRadiusRatioMobile : width * CONFIG.carouselRadiusRatioDesktop;
                }
                
                const targetCenterRatio = isMobile ? CONFIG.centerYMobile : CONFIG.centerYDesktop;
                const centerY = height * targetCenterRatio; 
                const fov = isMobile ? CONFIG.fovMobile : CONFIG.fovDesktop;
                const tiltFactor = isMobile ? CONFIG.tiltFactorMobile : CONFIG.tiltFactorDesktop;

                renderQueue = [];

                if (shouldUseSecretRadius) {
                    // ====== è™šæ‹Ÿå·è½´æ¸²æŸ“é€»è¾‘ (Virtual Scroll Logic) ======
                    // 1. è®¡ç®—æ¯ä¸ªæ§½ä½çš„è§’åº¦æ­¥é•¿
                    const slotAngleStep = (Math.PI * 2) / secretSlotCount;
                    
                    // 2. è®¡ç®—å½“å‰æ»šåŠ¨çš„åç§»é‡ (å°† globalRotation è½¬æ¢ä¸ºæ§½ä½ç´¢å¼•åç§»)
                    // globalRotation æ˜¯è¿ç»­çš„å¼§åº¦ã€‚æˆ‘ä»¬éœ€è¦çŸ¥é“å®ƒè½¬è¿‡äº†å¤šå°‘ä¸ª slotAngleStepã€‚
                    // æ³¨æ„æ–¹å‘ï¼šglobalRotation å¢åŠ ä»£è¡¨é€†æ—¶é’ˆæ—‹è½¬ã€‚
                    
                    // è®¡ç®—æ€»åç§»è§’åº¦ (å½’ä¸€åŒ–åˆ° 0 ~ 2PI ä¹‹å¤–ä¹Ÿè¡Œï¼Œåæ­£æˆ‘ä»¬å–æ¨¡)
                    // ä½¿ç”¨ floor ç¡®ä¿å¹³æ»‘è¿‡æ¸¡ï¼Œä¿ç•™å°æ•°éƒ¨åˆ†åšå¾®è°ƒ
                    const totalOffsetSteps = globalRotation / slotAngleStep;
                    
                    const indexShift = Math.floor(totalOffsetSteps);
                    const fineTuneAngle = (totalOffsetSteps - indexShift) * slotAngleStep;

                    // 3. éå†æ¯ä¸€ä¸ªç‰©ç†æ§½ä½ (0 åˆ° N-1)
                    for (let i = 0; i < secretSlotCount; i++) {
                        // è®¡ç®—è¯¥æ§½ä½å½“å‰åº”è¯¥æ˜¾ç¤ºçš„å­—ç¬¦ç´¢å¼•
                        // æ³¨æ„å¤„ç†è´Ÿæ•°å–æ¨¡çš„é—®é¢˜
                        let charIndex = (indexShift - i) % normalizedSecretText.length;
                        if (charIndex < 0) charIndex += normalizedSecretText.length;
                        
                        const char = normalizedSecretText[charIndex];
                        const particles = charParticleCache[char]; // ä»ç¼“å­˜å–ç‚¹é˜µ

                        if (particles) {
                            // è®¡ç®—è¯¥æ§½ä½çš„ç‰©ç†åŸºç¡€è§’åº¦
                            // æ³¨æ„ï¼šåŠ ä¸Š fineTuneAngle æ˜¯ä¸ºäº†è®©å­—åœ¨æ§½ä½ä¹‹é—´å¹³æ»‘æ»‘åŠ¨
                            const angle = i * slotAngleStep + fineTuneAngle;
                            
                            const cosA = Math.cos(angle);
                            const sinA = Math.sin(angle);

                            particles.forEach(p => {
                                p.update(); 
                                
                                // 3D æŠ•å½±é€»è¾‘ (Standard Cylinder Projection)
                                const x3d = p.relX * cosA + currentRadius * sinA;
                                const z3d = -p.relX * sinA + currentRadius * cosA;
                                const scale = fov / (fov + z3d);
                                const screenX = width / 2 + x3d * scale;
                                const screenY = centerY + (p.relY * scale) - (z3d * tiltFactor * scale);
                                
                                // Alpha æ¸å˜é€»è¾‘ - å¼•å…¥ fadePower
                                let progress = (currentRadius * 1.1 - z3d) / (2 * currentRadius * 1.1);
                                progress = Math.max(0, Math.min(1, progress));
                                let alpha = Math.pow(progress, CONFIG.secret.fadePower); 

                                if (scale > 0.1 && alpha > 0.005) {
                                     renderQueue.push({
                                         particle: p,
                                         scale: scale,
                                         x: screenX,
                                         y: screenY,
                                         alpha: alpha,
                                         z: z3d
                                     });
                                }
                            });
                        }
                    }

                } else {
                    // ====== åŸæœ‰çš„å›ºå®šåœ†ç¯æ¸²æŸ“é€»è¾‘ (Normal Ring Logic) ======
                    carouselGroups.forEach(group => {
                        const angle = group.baseAngle + globalRotation;
                        const cosA = Math.cos(angle);
                        const sinA = Math.sin(angle);

                        group.parts.forEach(p => {
                            p.update(); 
                            
                            // æ ¸å¿ƒ 3D æŠ•å½±é€»è¾‘
                            const x3d = p.relX * cosA + currentRadius * sinA;
                            const z3d = -p.relX * sinA + currentRadius * cosA;
                            const scale = fov / (fov + z3d);
                            const screenX = width / 2 + x3d * scale;
                            const screenY = centerY + (p.relY * scale) - (z3d * tiltFactor * scale);
                            
                            // Alpha æ¸å˜é€»è¾‘
                            let progress = (currentRadius * 1.1 - z3d) / (2 * currentRadius * 1.1);
                            progress = Math.max(0, Math.min(1, progress));
                            let alpha = Math.pow(progress, CONFIG.secret.fadePower); 

                            if (scale > 0.1 && alpha > 0.005) {
                                 renderQueue.push({
                                     particle: p,
                                     scale: scale,
                                     x: screenX,
                                     y: screenY,
                                     alpha: alpha,
                                     z: z3d
                                 });
                            }
                        });
                    });
                }

                // ç§»é™¤æ’åºï¼Œå› ä¸º lighter æ··åˆæ¨¡å¼ä¸‹ç»˜åˆ¶é¡ºåºä¸å½±å“ç»“æœ
                renderQueue.forEach(item => {
                    item.particle.draw(item.scale, item.x, item.y, item.alpha);
                });
            }
            requestAnimationFrame(animate);
        }
    </script>
</body>
</html>